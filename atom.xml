<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jarvis的天空</title>
  
  <subtitle>闲云野鹤</subtitle>
  <link href="http://jarvissky.com/atom.xml" rel="self"/>
  
  <link href="http://jarvissky.com/"/>
  <updated>2021-11-13T08:21:38.400Z</updated>
  <id>http://jarvissky.com/</id>
  
  <author>
    <name>Jarvis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective C++ 条款02: 尽量以const, enum, inline 替换#define</title>
    <link href="http://jarvissky.com/2021/11/13/Effective-C-%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline-%E6%9B%BF%E6%8D%A2-define/"/>
    <id>http://jarvissky.com/2021/11/13/Effective-C-%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline-%E6%9B%BF%E6%8D%A2-define/</id>
    <published>2021-11-13T08:20:10.000Z</published>
    <updated>2021-11-13T08:21:38.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款02-尽量以const-enum-inline-替换-define"><a href="#Effective-C-条款02-尽量以const-enum-inline-替换-define" class="headerlink" title="Effective C++ 条款02: 尽量以const, enum, inline 替换#define"></a>Effective C++ 条款02: 尽量以const, enum, inline 替换#define</h1><h2 id="1、-define-宏定义的记号名称从未被编译器看见"><a href="#1、-define-宏定义的记号名称从未被编译器看见" class="headerlink" title="1、#define  宏定义的记号名称从未被编译器看见"></a>1、#define  宏定义的记号名称从未被编译器看见</h2><p>【注意，作者这里没有称之为变量】<br>#define ASPECT_RATIO 1.653<br>ASPECT_RATIO这个记号也许从来就没有被编译器看见；也许在编译器开始处理源码之前他就被预处理器移走了。于是，ASPECT_RATIO根本没有进入符号表（symbol table）内。如果出现编译错误，可能编译器爆出的是1.653错了，。。。可能你压根想不到是自己定义的ASPECT_RATIO所指的意义。<br>预处理时会把源代码里的ASPECT_RATIO替换为 1.653，没有类型检查</p><h2 id="2、解决之道：用一个常量替换上述的宏（-define）"><a href="#2、解决之道：用一个常量替换上述的宏（-define）" class="headerlink" title="2、解决之道：用一个常量替换上述的宏（#define）"></a>2、解决之道：用一个常量替换上述的宏（#define）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double AspectRatio &#x3D; 1.653;  &#x2F;&#x2F;大写常用与宏，因此这里用变量名的定义规则</span><br></pre></td></tr></table></figure><p>作为一个语言常量，AspectRatio肯定会被编译器看到，当就会进入记号表内。此外对浮点常量（floating point constant,）而言，使用常量可能比使用#define导致较小的码，因为预处理器”盲目地将宏名称ASPECT_RATIO替换为1.653”可能导致目标码（object code）出现多分1.653，若改为常量AspectRatio绝不会出现相同的情况。</p><h3 id="2-1-用常量指针（constant-pointers）"><a href="#2-1-用常量指针（constant-pointers）" class="headerlink" title="2.1 用常量指针（constant pointers）"></a>2.1 用常量指针（constant pointers）</h3><p>由于常量定义式通常被放在头文件内（以便被不同的源码引入），因此有必要将指针（而不是指针所指之物）声明为const。例如若要在头文件内定义一个常量（不变的）char*-based字符串，必须写两次const:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* const authorName &#x3D; &quot;Scott Meyers&quot;;</span><br></pre></td></tr></table></figure><p>C++定义常量时，使用string对象更合时宜</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const std::string authorName(&quot;Scott Meyers&quot;); </span><br></pre></td></tr></table></figure><h3 id="2-2-class-专属常量"><a href="#2-2-class-专属常量" class="headerlink" title="2.2 class 专属常量"></a>2.2 class 专属常量</h3><p>为了将常量的作用域限制在class内，必须让它成为class 的一个成员（member）;而确保此常量至多只有一份实体，必须让它成为一个static成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">  static const int NumTurns &#x3D; 5;  &#x2F;&#x2F;  声明类内常量</span><br><span class="line">  int scores[NumTurns];  &#x2F;&#x2F;使用该常量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，这里所看到的是 NumTurns的声明式。通常C++要求你对你所使用的任何东西提供一个定义式，但如果它是个class专属常量又是static 且为正数类型（integral type, 例如 ints, cahrs, bools）,则需要特殊处理。只要不取他们的地址，你可以声明并使用它们，而无需提供定义式。但如果你取某个class专属常量的地址，或纵使你不取其地址而你的编译器却坚持（不正确地）坚持要看到一个定义式，你就必须另外提供定义式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int GamePlayer::NumTurns;  &#x2F;&#x2F;NumTurns的定义，下面告诉你为什么没有给予数值</span><br></pre></td></tr></table></figure><p>请把这个式子放进一个实现文件而非非头文件。由于class 常量已在声明时获得初值（例如先前声明NumTurns 时为它设初值5），因此定义时不可以再设置初值。<br><strong>不可以在class内使用宏定义</strong><br>如果编译器不支持上诉语法，可以将初值放在定义式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ConstEstimate &#123;</span><br><span class="line">private:</span><br><span class="line">  static const double FudgeFactor;  &#x2F;&#x2F; static class 常量声明，位于头文件内</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;static class 常量声明位于头文件内</span><br><span class="line">const double ConstEstimate::FudgeFactor &#x3D; 1.35;</span><br></pre></td></tr></table></figure><p>这几乎是你在任何时候唯一需要做的事情。唯一例外是当你子class编译期间需要一个class常量值，例如在上述的GamePlayer::scores的数组声明式中（是的，编译器坚持必须在编译期间知道数组的大小）。这时候万一你的编译器（错误地）不允许”static 整数型class常量”完成”in class初值设定”，可改用所谓的”the enum hack “补偿做法。其理论基础是：”一个属于枚举类型（enumerated type）的数值可权充ints被使用”，于是 GamePlayer可定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">  enum &#123; NumTurns &#x3D; 5&#125;;&#x2F;&#x2F;&quot;the enum hack&quot;令NumTurns 成为5的一个记号名称。这就没问题了</span><br><span class="line">  int scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于”the enum hack”<br>1、enum hack 的行为某方面说比较像#define而不像cosnt, 有时候这正是你想要的，例如 取一个const的地址是合法的，但是去一个enum的地址就是不合法，而取一个#define的地址通常也不合法。<br>如果你想不让别人获得一个pointer或reference指向你的某个整数常量，enum 可以帮助你实现这个约束。条款18”通过撰写码时决定实施设计上的约束条件谈的更多”。<br>2、虽然优秀的编译器不会为”整数型const对象”设定另外的存储空间（除非你创建一个pointer 或 reference指向该对象）不够优秀的编译器却可能如此，而这可能是你不想要的。Enums 和 #define一样绝不会导致非必要的内存分配。<br>3、enum hack 纯粹是为了实用主义。许多代码用了它。它是模板元编程（template metaprogramming）的基础技术。</p><h2 id="3、预处理器的错误用法"><a href="#3、预处理器的错误用法" class="headerlink" title="3、预处理器的错误用法"></a>3、预处理器的错误用法</h2><p>宏函数：看起来像函数，但不会招致函数调用（function call）带来的额外开销。下面这个宏夹带着宏实参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以a和b 的较大值调用f</span><br><span class="line">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br></pre></td></tr></table></figure><p>那么多括号，看起来都烦啊。但是宏中的实参必须用括号扩起来，否则别人调用可能会有麻烦。<br>就算加了小括号，还有可能出现不可思议的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a  &#x3D; 5, b &#x3D; 0;</span><br><span class="line">CALL_WITH_MAX(++a, b);&#x2F;&#x2F; a 被累加两次</span><br><span class="line">CALL_WITH_MAX(++a, b + 10);  a被累加一次</span><br></pre></td></tr></table></figure><p>在这里，调用f之前，a的递增次数竟然取决于”它被拿来和谁比较”！</p><p>幸运的是，我们有办法解决这个问题。你可以获得宏带来的效率以及一般函数所有可能预料行为和类型安全性（type safety）—-只要写出template inline 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;由于我们不知道T是什么，所以采用pass by reference-to-const. 条款20</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T&amp; a, const T&amp; b) &#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个tempalte产出一整群函数，每个函数都可以接受两个同类型对象，并以其中较大者调用f。这里不需要在函数本体中为参数加上括号，也不需要操心参数被核算（求值）多次……等等。此外 callWithMax是一个真正的函数，它遵守作用域（scope）和访问规则。<br>你绝对可以写一个”class 内的private inline函数”。一般而言宏无法完成此事。</p><p>有了 const, enum ,inline。我们对预处理器的需求就降低了。<br>但并未完全消除，#include  仍然是必需品，而 #ifdef/#ifndef也继续扮演控制编译器的重要角色。目前还不到预处理器全面隐退的时候。</p><ul><li>对于单纯的常量，最好以cosnt对象或enum 替换#define</li><li>对于形似函数的宏macros, 最好改用 inline 函数替换 #define</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款02-尽量以const-enum-inline-替换-define&quot;&gt;&lt;a href=&quot;#Effective-C-条款02-尽量以const-enum-inline-替换-define&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>视C++为一个语言联邦</title>
    <link href="http://jarvissky.com/2021/11/13/%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/"/>
    <id>http://jarvissky.com/2021/11/13/%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/</id>
    <published>2021-11-13T07:39:22.000Z</published>
    <updated>2021-11-13T07:42:22.040Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 是支持多重范性编程的语言<br>面向过程编程（procedural）<br>面向对象形式（object-oriented)<br>函数形式（functional)<br>范型形式（generic)<br>元编程形式（metaprogramming)</p><p>不同的编程模式需要遵循一些特定的规约，所以C++在不同的时候需要使用不同的规约特性：<br>最简单的方法是将C++视为一个由相关语言组成的联邦，而非单一语言。在其某个次语言sublanguage中，各种守则与通例都倾向简单、直观易懂、并且容易记住。<br>当你从一个次语言移往另一个次语言，守则可能改变。因此，为了理解C++,必须认识其主要的次语言。幸运的是总共只有4个。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>说到底C++仍是以C为基础。区块（blocks）,语句（statements)、预处理器（preprocessor)、内置类型（build-in data types)、数组（arrays）、指针（pointers）、等统统来自C。许多时候C++问题的解法其实不过就是较高级的C解法（例如条款2谈到预处理器之外的另一选择），条款13谈到以对象管理资源，当你以C++内的C成分工作时，高效守则映射出C语言的局限：没有模板（templates）,没有异常（exceptions),没有重载（overloading)…</p><h2 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h2><p>这部分也就是C with classes 所诉求的：classes（包括构造函数和析构函数），封装（encapsulation）,继承（inheritance）,多态（ploymorphism），virtual函数（动态绑定）等等。这一部分是面向对象设计之古典守则在C++上最直接实施。</p><h2 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h2><p>这是C++的范型编程（generic programming）部分，也是大多数程序员经验最少的部分。Template 相关考虑与设计已经弥漫整个C++,良好编程守则中”维template适用”的特殊条款并不罕见（例如条款46谈到调用template functions时如何协助类型转换）。实际上由于templates 威力强大，它们带来崭新的变成范型（programming paradigm）,也即是所谓的template metaprogramming（TMP,模板元编程）。条款48对此提供了一份概述，但除非你是template激进团队的中坚骨干，大可不必太担心这些。TMP相关规则很少与C++主流编程相互影响。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL是template程序库，但它非常特殊。它对容器（containers）、迭代器（iterators）、算法（algorithms）以及函数对象（function objects）的规约有极佳的紧密配合与协调，然而templates及程序库也可以其他想法建置起来。STL有自己特殊的办事方式，当你伙同STL一起工作，你必须遵守它的规约。</p><p>这四种次语言切换时规约会变，不必惊讶。<br>例如对内置类型而言（pass-by-value）通常比（pass-by-reference） 高效，但当你从C part of C++ 移往Object-Oriented C++,由于用户自定义（user-defined)构造函数和析构函数的存在，pass-by-reference-to-const往往更好。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦阔如STL你就会了解，迭代器和函数对象都是在C++指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的Cpass-by-value守则再次适用。（参数传递参照条款20）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++ 是支持多重范性编程的语言&lt;br&gt;面向过程编程（procedural）&lt;br&gt;面向对象形式（object-oriented)&lt;br&gt;函数形式（functional)&lt;br&gt;范型形式（generic)&lt;br&gt;元编程形式（metaprogramming)&lt;/p&gt;
&lt;p&gt;不</summary>
      
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>how to post your first Hexo blog</title>
    <link href="http://jarvissky.com/2021/11/13/how-to-post-your-first-Hexo-blog/"/>
    <id>http://jarvissky.com/2021/11/13/how-to-post-your-first-Hexo-blog/</id>
    <published>2021-11-13T06:26:46.000Z</published>
    <updated>2021-11-13T07:37:02.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何用Hexo创建一个博客"><a href="#如何用Hexo创建一个博客" class="headerlink" title="如何用Hexo创建一个博客"></a>如何用Hexo创建一个博客</h1><p>[toc]</p><h2 id="0、用以下命令来创建一篇博客或者一个新的页面"><a href="#0、用以下命令来创建一篇博客或者一个新的页面" class="headerlink" title="0、用以下命令来创建一篇博客或者一个新的页面"></a>0、用以下命令来创建一篇博客或者一个新的页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout）,默认为post,可以通过_config.yml 中的 default_layout 参数来指定默认布局。</p><h2 id="1、布局"><a href="#1、布局" class="headerlink" title="1、布局"></a>1、布局</h2><p>Hexo 有三种默认的布局：post、page、draft</p><p>在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而你自定义的其他布局和post相同，都将存储到 source/_posts文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_post</td></tr><tr><td>page</td><td>soruce</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><p>这个一般用默认的时候</p><span id="more"></span><h2 id="2、文件名称"><a href="#2、文件名称" class="headerlink" title="2、文件名称"></a>2、文件名称</h2><p>Hexo 默认以标题作为文件名称，但你可以编辑 new_post_name 参数来改变默认的文件名称，例如：将文件名称设置为**:year-:month-:day-:title.md**可以让你更方便的通过日期来管理文章。</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>:title</td><td>标题，（小写，空格会被替换为横杠）</td></tr><tr><td>:year</td><td>建立年份</td></tr><tr><td>:month</td><td>建立月份（有前导0），比如四月：04</td></tr><tr><td>:i_month</td><td>建立月份（无前导0），比如四月：4</td></tr><tr><td>:day</td><td>建立日期（有前导0），比如七号：07</td></tr><tr><td>:i_day</td><td>建立日期（无前导0），比如七号：7</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="3、草稿"><a href="#3、草稿" class="headerlink" title="3、草稿"></a>3、草稿</h2><p>创建文稿时，Hexo的一种特殊布局时：draft,这种布局在建立时会被保存到 /source/_draft 文件夹内，可通过 <em>public</em>命令将草稿移动到 source/_post文件夹，该命令的使用方式与new十分类似，你也可以在命令中指定 layout 来定制布局方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，你可以在执行中加上 –draft 参数，或把 render_draft  参数设为 true 来预览草稿。</p><h2 id="4、模板（Scaffold）"><a href="#4、模板（Scaffold）" class="headerlink" title="4、模板（Scaffold）"></a>4、模板（Scaffold）</h2><p>在新建文章时，Hexo 会根据scaffolds 文件夹内响应的文件夹来建立文件，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new photo <span class="string">&quot;My Gallery&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这些命令时，Hexo会尝试在 scaffold文件夹中寻找 photo.md, 并根据其内容建立文章，以下时你可以在模板中使用的变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>layout</td><td>布局</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>date</td><td>文件建立日期</td></tr></tbody></table><h2 id="5、支持格式"><a href="#5、支持格式" class="headerlink" title="5、支持格式"></a>5、支持格式</h2><p>Hexo 支持以任何格式书写文章，只要安装了响应的渲染插件</p><p>Hexo，默认安装了 <strong>hexo-renderer-marked</strong> 和 <strong>hexo-renderer-ejs</strong>, 因此你不仅可以用markdown写作，还可以用EJS 写作。如果你安装了<strong>hexo-renderer-pug</strong>,你甚至可以使用Pug模板语法书写文章。</p><p>只需要将文章的扩展名从 md 改为 ejs, Hexo就会使用 hexo-renderer-ejs渲染整个文件，其它格式同理。</p><h2 id="6、front-matter"><a href="#6、front-matter" class="headerlink" title="6、front-matter"></a>6、front-matter</h2><p>front-matter是文件最上方以**—** 分割区域，用于指定个别文件的变量，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: how-to-post-your-first-Hexo-blog</span><br><span class="line">data: 2021/11/13</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预定义参数：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件的建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件的更新日期</td></tr><tr><td>comments</td><td>开启文章评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td></td></tr><tr><td>excerpt</td><td>页面期望用纯文本展示，用这个插件来格式化文本</td><td></td></tr><tr><td>disableNunjunks</td><td>禁止渲染 Numjunks tag,需要用到 tag plugins</td><td></td></tr><tr><td>lang</td><td>设置语言来覆盖自动检测的配置</td><td>继承与 _config.yml</td></tr></tbody></table><h2 id="7、分类和标签"><a href="#7、分类和标签" class="headerlink" title="7、分类和标签"></a>7、分类和标签</h2><p>只有文章支持分类和标签，你可以在front-matter中设置。在其他系统中分类和标签听起来很类似，但是Hexo中二者有明显的差别，分类具有顺序和层次性，也就是说Foo, Bar不等于Bar，Foo;而 标签没有顺序和层次。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> iOS</span><br><span class="line"><span class="bullet">-</span> Swift</span><br></pre></td></tr></table></figure><p>分类方法的分歧</p><p>wordpress中，一篇文章中可以设置多个分类，这些分类可以使同层级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line"><span class="bullet">-</span> Life</span><br></pre></td></tr></table></figure><p>上面的分类犯法会使 Lift成为Diary的子类，而不是并列分类。因此，有必要为你的文章尽可能准确的分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> [Diary, Eat]</span><br><span class="line"><span class="bullet">-</span> [Dirary, Games]</span><br><span class="line"><span class="bullet">-</span> [Lift]</span><br></pre></td></tr></table></figure><p>这时，这篇文章同时包含了三个分类：Diary,是一个分类，且有两个分类：Eat,Game.同时Life是一个没有子分类的分类。</p><h2 id="Json-front-matter"><a href="#Json-front-matter" class="headerlink" title="Json front-matter"></a>Json front-matter</h2><p>除了 YAML 外，你也可以 使用 JSON来编写 Front-matter，只要将 — 替换为 ；；；即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;title&quot;: &quot;title name&quot;</span><br><span class="line">&quot;date&quot;: &quot;20211113&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><h2 id="8、开始写文章"><a href="#8、开始写文章" class="headerlink" title="8、开始写文章"></a>8、开始写文章</h2><p>这样文章的标题和基本配置信息就搞定了。</p><p>剩下的就是根据markdown  语法写文章了</p><p>参考链接 <a href="https://hexo.io/zh-cn/docs/front-matter">hexo中文官方文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何用Hexo创建一个博客&quot;&gt;&lt;a href=&quot;#如何用Hexo创建一个博客&quot; class=&quot;headerlink&quot; title=&quot;如何用Hexo创建一个博客&quot;&gt;&lt;/a&gt;如何用Hexo创建一个博客&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;0、用以下命令来创建一篇博客或者一个新的页面&quot;&gt;&lt;a href=&quot;#0、用以下命令来创建一篇博客或者一个新的页面&quot; class=&quot;headerlink&quot; title=&quot;0、用以下命令来创建一篇博客或者一个新的页面&quot;&gt;&lt;/a&gt;0、用以下命令来创建一篇博客或者一个新的页面&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new [layout] &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以在命令中指定文章的布局（layout）,默认为post,可以通过_config.yml 中的 default_layout 参数来指定默认布局。&lt;/p&gt;
&lt;h2 id=&quot;1、布局&quot;&gt;&lt;a href=&quot;#1、布局&quot; class=&quot;headerlink&quot; title=&quot;1、布局&quot;&gt;&lt;/a&gt;1、布局&lt;/h2&gt;&lt;p&gt;Hexo 有三种默认的布局：post、page、draft&lt;/p&gt;
&lt;p&gt;在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而你自定义的其他布局和post相同，都将存储到 source/_posts文件夹。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;布局&lt;/th&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;source/_post&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;soruce&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;draft&lt;/td&gt;
&lt;td&gt;source/_drafts&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;这个一般用默认的时候&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="http://jarvissky.com/categories/hexo/"/>
    
    <category term="create blog" scheme="http://jarvissky.com/categories/hexo/create-blog/"/>
    
    
    <category term="hexo" scheme="http://jarvissky.com/tags/hexo/"/>
    
    <category term="blog" scheme="http://jarvissky.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>swift GCD</title>
    <link href="http://jarvissky.com/2021/04/24/swift%20GCD/"/>
    <id>http://jarvissky.com/2021/04/24/swift%20GCD/</id>
    <published>2021-04-24T05:01:52.000Z</published>
    <updated>2021-04-24T11:02:58.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift5-x-中-GCD"><a href="#swift5-x-中-GCD" class="headerlink" title="swift5.x 中 GCD"></a>swift5.x 中 GCD</h1><p>[TOC]</p><p>swift 5.x对GCD封装了更加便捷的API,通过这些丰富的API,可以轻松实现多线程编程.</p><h2 id="0-队列和任务"><a href="#0-队列和任务" class="headerlink" title="0. 队列和任务"></a>0. 队列和任务</h2><p>在iOS多线程编程的术语里，最先要理解的两个概念就是队列和任务。</p><p>队列：就是任务执行的一个排队的空间。分为串行队列，并发队列。</p><p>任务：任务是计算机要处理的一段程序。</p><p>同步处理任务，就像是接力棒赛跑，上个人跑完了自己的路程，下个人继续下一段赛程，它有一个先后顺序。</p><p>异步处理任务，是针对多核计算机的，在单核计算机里是没有多线程的概念的，也就没有异步处理任务的说法，所有提交给CPU的任务，只有排队，一个个的处理。多核计算机异步处理任务，就是多个任务系统会统一调度，让CPU多个核心去同时处理多个任务。<strong>也是多线程编程的原因所在，多线程编程让充分发挥系统性能，提高程序运行效率。</strong>多线程编程就是程序员利用系统提供的API,根据业务要求编写出高效的程序。</p><p> 苹果提供的GCD便是一个多多线程编程的强大类库。</p><ol><li>GCD可用于多核的并行运算， </li><li>GCD会自动利用更多的CPU内核</li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li></ol><span id="more"></span><h2 id="1、swfit中用GCD创建一个队列"><a href="#1、swfit中用GCD创建一个队列" class="headerlink" title="1、swfit中用GCD创建一个队列"></a>1、swfit中用GCD创建一个队列</h2><h3 id="1-1-行队列的创建"><a href="#1-1-行队列的创建" class="headerlink" title="1.1 行队列的创建"></a>1.1 行队列的创建</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建</span></span><br><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>, qos: .default, attributes: .<span class="keyword">init</span>(rawValue: <span class="number">0</span>), autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//也可以简单些，除了指定一个label,其它的参数都可以使用一个默认值</span></span><br><span class="line"><span class="keyword">let</span> sQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(lable: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发队列的创建</span></span><br><span class="line"><span class="keyword">let</span> coucurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>, qos: .default, attributes: .coucurrent, autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明 </p><ul><li><p>label: 队列的名字，可以根据项目的bundleID 和功能模块来定义例如<em>com.wjw.SwiftTips.seraialQueue</em></p></li><li><p>qos:    服务质量优先级，队列的优先级。Objective-C中，有四种优先级分别是： </p><p>DISPATCH_<em>QUEUE</em>_PRIORITY_HIGHT</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_DEFAULT</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_LOW</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_BACKGROUND</p><p>而在swift中共有6中，默认是unspecified，其它几种和优先级排序是userInteractive &gt; userInitiated &gt; default &gt; utility &gt; background &gt; unspecified</p><p> public static let userInteractive: DispatchQoS 用户交互 </p><p>public static let userInitiated: DispatchQoS 用户发起</p><p> public static letdefault: DispatchQoS 默认优先级</p><p> public static let utility: DispatchQoS 对应oc中的low 低 </p><p>public static let background: DispatchQoS 后台 </p><p>public static let unspecified: DispatchQoS 不指定优先级</p></li><li><p>attributes: 指定队列性质，是串行队列还是并发队列</p><ul><li>concurrent: 表示队列是并行队列</li><li>没有该参数，默认创建的就是串行队列</li><li>initiallyInactive，标识队列中的任务不会自动执行，需要由队列的activate来触发，如果不添加该标识，队列中的任务会自动运行。</li></ul></li><li><p>autoreleaseFrequency： 类型为枚举类型，用来管理任务内对象的生命周期的自动释放的频率</p><ul><li>inherit: 继承目标队列的该属性</li><li>workItem: 跟随每个任务的执行周期进行自动创建和释放</li><li>nerver: 不会创建自动释放池</li></ul><p>一般用workItem即可，不指定target参数时，应该是系统管理释放频率。</p></li><li><p>target: 设置队列的目标队列，即队列中的任务运行时，实际所在的队列。目标队列最终决定了队列的优先级等级。</p><p>在程序中手动创建的队列最终都指向了系统自带的主队列或全局并发队列。</p></li></ul><h3 id="1-2-系统队列"><a href="#1-2-系统队列" class="headerlink" title="1.2 系统队列"></a>1.2 系统队列</h3><h4 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h4><p>一切UI线程的刷新都在主线程中进行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个主队列</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main</span><br></pre></td></tr></table></figure><h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取全局队列</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>我们一般的需要在子线程中进行处理的耗时任务都可以在全局队列中进行。不过也有例外，有时我们利用全局队列反而会发生一些意料不到的问题。后面会讲到。</p><h2 id="2、在一个队列中执行任务"><a href="#2、在一个队列中执行任务" class="headerlink" title="2、在一个队列中执行任务"></a>2、在一个队列中执行任务</h2><p>任务的执行分为 同步执行和异步执行</p><h3 id="2-1-在主队列中执行任务"><a href="#2-1-在主队列中执行任务" class="headerlink" title="2.1 在主队列中执行任务"></a>2.1 在主队列中执行任务</h3><p>我们不做任何处理，在viewDidload 里写的这些代码默认都是在主队列里执行的，这也是为什么页面复杂的时候，加载页面会出现卡顿的原因所在。</p><p>以下代码是绝对不允许直接出现的，在主队列（由于主队列只有一个线程同步执行，我们也叫它主线程）中同步处理任务会造成死锁。</p><p>主线程中的任务都是同步执行的，下面的同步任务执行需要等待主线程让出资源，但是主线程是内存常驻的，它管理整个程序的UI加载刷新，是不可能让出的,主线程完成了应用就退出了，让同步的让主线程执行自定义的打印任务就会一直得不到资源，造成死锁。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程同步执行一个任务【会造成死锁】</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;主队列 同步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程异步执行一个任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;主队列 异步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-在全局队列中执行任务"><a href="#2-2-在全局队列中执行任务" class="headerlink" title="2.2 在全局队列中执行任务"></a>2.2 在全局队列中执行任务</h3><p>在全局队列中同步执行一个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局队列中同步执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;全局队列 同步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局队列中异步执行任务，会自动管理任务的执行，要不要直接在全局队列中执行，还是由全局队列再创建新的线程执行。我们都不用再操心了。</p><p>全局队列中异步执行一个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局队列中异步执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;全局队列 异步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这里需要补充一下 全局队列异步执行多个任务，barrier是没有用的。正如我们上面提到的，全局队列为了执行效率，并没有检查 barrier。</p><h2 id="3、串行并行嵌套问题"><a href="#3、串行并行嵌套问题" class="headerlink" title="3、串行并行嵌套问题"></a>3、串行并行嵌套问题</h2><h3 id="3-1-串行队列中同步执行任务"><a href="#3-1-串行队列中同步执行任务" class="headerlink" title="3.1 串行队列中同步执行任务"></a>3.1 串行队列中同步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列 同步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">serialQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;串行队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;串行队列1&quot;</span>, qos: .default, attributes: .<span class="keyword">init</span>(rawValue: <span class="number">0</span>), autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">            serialQueue.async &#123;</span><br><span class="line">                sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码会依次输入0到9</p><p>可见，串行队列中同步执行和我们平日里写一个for循环是一样的。并没有体现多线程编程的优越性，由于我们让打印随机延时输出，会发现打印全的时间是全部随机时间之和。没有提高效率。</p><h3 id="3-2-串行队列中异步执行任务"><a href="#3-2-串行队列中异步执行任务" class="headerlink" title="3.2 串行队列中异步执行任务"></a>3.2 串行队列中异步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列， 异步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">serialQueueAsyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;串行队列+异步任务——开启一个新线程依次执行&quot;</span>)</span><br><span class="line">  <span class="comment">//串行队列</span></span><br><span class="line">  <span class="keyword">let</span> serial <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;串行队列2&quot;</span>,attributes: .<span class="keyword">init</span>(rawValue:<span class="number">0</span>))</span><br><span class="line">  <span class="built_in">print</span>(<span class="type">Thread</span>.current)<span class="comment">//主线程</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    serial.async &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)<span class="comment">//子线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现，打印速度比第一种情况要快。主线程打印的  NSThread ，number == 1， 新创建的线程是number == 35，可见异步编程提高了程序运行效率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">串行队列+异步任务——开启一个新线程依次执行</span><br><span class="line">&lt;NSThread: 0x600003520140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">0 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">1 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">2 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">3 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">4 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">5 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">6 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">7 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">8 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">9 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">10 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-并行队列中同步执行任务"><a href="#3-3-并行队列中同步执行任务" class="headerlink" title="3.3 并行队列中同步执行任务"></a>3.3 并行队列中同步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+同步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;并发队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">  <span class="comment">//以下代码输出顺序始终为0...10,且线程始终为主线程</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().sync &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，全局队列中同步执行任务，会在主线程中依次执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列+同步任务——依次执行</span><br><span class="line">0 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">6 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">7 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">8 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">9 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">10 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个并发队列，然后同步执行</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+同步执行</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;并发队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">        <span class="comment">//以下代码输出顺序始终为0...10,且线程始终为主线程</span></span><br><span class="line">        <span class="keyword">let</span> conQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.swiftTips.concurrentQueue&quot;</span>, qos: .default, attributes: .concurrent  , autoreleaseFrequency: .workItem, target: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">            conQueue.sync &#123;</span><br><span class="line">                sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">                <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果依旧是这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">并发队列+同步任务——依次执行</span><br><span class="line">0 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">6 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">7 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">8 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">9 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">10 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由以上可以确定，就是是并发队列，同步执行的任务，只会在主线程中依次执行。</p><h3 id="3-4-并行队列中异步执行任务"><a href="#3-4-并行队列中异步执行任务" class="headerlink" title="3.4 并行队列中异步执行任务"></a>3.4 并行队列中异步执行任务</h3><p>全局队列中异步执行多个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+异步任务</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueAsyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;并发队列+异步任务  开启多个线程并发执行&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现打印结果迅速，并不会像第一种情形，每次打印都等待随机延迟时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列+异步任务——开启多个线程并发执行</span><br><span class="line">0 &lt;NSThread: 0x600003031280&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2 &lt;NSThread: 0x600003005c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">3 &lt;NSThread: 0x600003008880&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">5 &lt;NSThread: 0x600003006280&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">8 &lt;NSThread: 0x600003007380&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">9 &lt;NSThread: 0x600003048e80&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">1 &lt;NSThread: 0x60000306c440&gt;&#123;number = 13, name = (null)&#125;</span><br><span class="line">4 &lt;NSThread: 0x600003031280&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">7 &lt;NSThread: 0x600003005c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">10 &lt;NSThread: 0x600003008880&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">6 &lt;NSThread: 0x600003074300&gt;&#123;number = 14, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>是并发+异步编程提升了程序的处理效率。</p><p>实际上，同步就是在当前线程中执行任务。异步就是GCD会创建新的线程，在多个cpu核心里执行任务。从而利用硬件性能，提高程序运行效率。</p><p>关于队列的串行，并行网上许多资料也提到，并行叫并发更合适。</p><p>并发字面意思体现在这些多个任务同时被提交给CPU,它们的执行期间并排执行的时间差异很大时，并行的描述并不形象。例如一个1ms执行完的任务和一个10min执行的任务并行执行的时间只有1ms，但是说成是并发，就可以理解为他们一同出发，谁先到达终点，我们就不用管了，也管不了。</p><p>当然这都是些文字游戏，主要能帮我们加深理解。</p><h2 id="4、GCD-group"><a href="#4、GCD-group" class="headerlink" title="4、GCD group"></a>4、GCD group</h2><h3 id="4-1-GCD-group的使用"><a href="#4-1-GCD-group的使用" class="headerlink" title="4.1 GCD group的使用"></a>4.1 GCD group的使用</h3><p>实际开发当中，由于异步执行结束的时间不确定，我们在很多场景下会遇到要求任务A，B执行完以后，任务C才执行。A,B这类任务是前置任务，C是后置任务。为满足这样的场景。利用group就可以很方便的实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">groupTest1</span>()</span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;gcd group的使用&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">  <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务A-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务B-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务C-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//group完成时，指定在某个队列中执行一个后续任务</span></span><br><span class="line">  group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group中所有的任务都完成了,执行此处操作&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，group结束时，可以用notify和wait来通知任务执行完的状态,其中，notify不能设置超时时间，而wait可以。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> group.wait(timeout: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> .success:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;group 执行完成&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .timedOut:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;group 执行超时&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-group-enter-group-leave"><a href="#4-2-group-enter-group-leave" class="headerlink" title="4.2 group.enter(), group.leave()"></a>4.2 group.enter(), group.leave()</h3><p>group.enter() 和 group.leave() 必须成对出现。</p><p>group.enter() 出现在任务执行开始前，group.leave() 出现在任务执行结束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">groupTest2</span>()</span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;gcd group的使用&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务A-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务B-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务C-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group中所有的任务都完成了&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来和不加enter,leave并没有太大区别，但是第一个示例，我们的任务都是在自己定义的队列里执行。倘若，我们的拿不到执行任务的队列，比如执行任务的队列是第三方库提供的。我们就需要用到这一对操作。</p><h2 id="5-延迟执行-asyncAfter"><a href="#5-延迟执行-asyncAfter" class="headerlink" title="5. 延迟执行 asyncAfter"></a>5. 延迟执行 asyncAfter</h2><p>延迟执行很简单，利用asyncAfter 即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">dispatchAfter</span>()</span> &#123;</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().asyncAfter(deadline: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span> ) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">5</span>, <span class="string">&quot;秒之后执行&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、信号量"><a href="#6、信号量" class="headerlink" title="6、信号量"></a>6、信号量</h2><p>信号量是多线程编程中标识可用资源数。 由于计算机必须具备了可用资源才能执行程序，我们可以利用信号量这一特点，需求来完成一些骚操作。</p><ol><li><p>信号量的创建  let semaphore = DispatchSemaphore.init(value: 0)</p></li><li><p>信号量的-1 wait   semaphore.wait() </p><p>信号量&gt;0时，可以执行代码区，并把信号量-1，当信号量为0时，后续提交的任务都要等待。</p></li><li><p>信号量的+1   semaphore.singnal()</p><p>代码区执行完信号量+1</p></li></ol><ul><li><p>信号量可以处理异步任务的同步</p><p>我们把信号量设置为0，完成任务时发送一次信号，标识只有一个可用资源，那么其它线程执行到这里就只能放行一个，完成了-1.从而达到把异步任务同步化的目的。这里把异步任务同步化处理一般是为了满足具体的业务需求，并不会和异步编程能提高程序运行效率相矛盾。</p></li><li><p>设置异步线程的最大任务并发数max</p><p>把信号量的值设置为最大并发数，执行任务前先-1， 完成了+1；当提交的任务数大于max，时，只要执行中的任务还没有释放资源，就不会再有新的任务执行。</p></li><li><p>设置锁</p><p>把信号量的值设置为1，执行任务时，先-1，就可以阻塞当前线程，</p></li></ul><h3 id="6-1-信号量处理同步"><a href="#6-1-信号量处理同步" class="headerlink" title="6.1 信号量处理同步"></a>6.1 信号量处理同步</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量处理同步</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreSync</span>()</span> &#123;</span><br><span class="line">  <span class="comment">//创建信号量为0</span></span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">0</span>)</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">    sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)</span><br><span class="line">    <span class="comment">//信号量+1</span></span><br><span class="line">    semaphore.signal()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待，信号量大于0，可以继续执行并将信号量-1，信号量=0,阻塞</span></span><br><span class="line">  <span class="keyword">switch</span> semaphore.wait(timeout: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> .success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信号量控制的同步任务完成&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .timedOut:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信号量控制的同步任务超时&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-信号量控制最大并发量"><a href="#6-2-信号量控制最大并发量" class="headerlink" title="6.2 信号量控制最大并发量"></a>6.2 信号量控制最大并发量</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量控制最大并发量</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreMaxConcurrent</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;信号量控制最大并发量&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span> &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">      sleep(arc4random() <span class="operator">%</span> <span class="number">3</span>)</span><br><span class="line">      <span class="built_in">print</span>(i, <span class="type">Thread</span>.current)</span><br><span class="line">      semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-锁"><a href="#6-3-锁" class="headerlink" title="6.3 锁"></a>6.3 锁</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>信号量枷锁</span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreAsLock</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;信号量枷锁&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">1</span>)</span><br><span class="line">  semaphore.wait()</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模拟任务&quot;</span>, <span class="type">Thread</span>.current)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;swift5-x-中-GCD&quot;&gt;&lt;a href=&quot;#swift5-x-中-GCD&quot; class=&quot;headerlink&quot; title=&quot;swift5.x 中 GCD&quot;&gt;&lt;/a&gt;swift5.x 中 GCD&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;swift 5.x对GCD封装了更加便捷的API,通过这些丰富的API,可以轻松实现多线程编程.&lt;/p&gt;
&lt;h2 id=&quot;0-队列和任务&quot;&gt;&lt;a href=&quot;#0-队列和任务&quot; class=&quot;headerlink&quot; title=&quot;0. 队列和任务&quot;&gt;&lt;/a&gt;0. 队列和任务&lt;/h2&gt;&lt;p&gt;在iOS多线程编程的术语里，最先要理解的两个概念就是队列和任务。&lt;/p&gt;
&lt;p&gt;队列：就是任务执行的一个排队的空间。分为串行队列，并发队列。&lt;/p&gt;
&lt;p&gt;任务：任务是计算机要处理的一段程序。&lt;/p&gt;
&lt;p&gt;同步处理任务，就像是接力棒赛跑，上个人跑完了自己的路程，下个人继续下一段赛程，它有一个先后顺序。&lt;/p&gt;
&lt;p&gt;异步处理任务，是针对多核计算机的，在单核计算机里是没有多线程的概念的，也就没有异步处理任务的说法，所有提交给CPU的任务，只有排队，一个个的处理。多核计算机异步处理任务，就是多个任务系统会统一调度，让CPU多个核心去同时处理多个任务。&lt;strong&gt;也是多线程编程的原因所在，多线程编程让充分发挥系统性能，提高程序运行效率。&lt;/strong&gt;多线程编程就是程序员利用系统提供的API,根据业务要求编写出高效的程序。&lt;/p&gt;
&lt;p&gt; 苹果提供的GCD便是一个多多线程编程的强大类库。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCD可用于多核的并行运算， &lt;/li&gt;
&lt;li&gt;GCD会自动利用更多的CPU内核&lt;/li&gt;
&lt;li&gt;GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://jarvissky.com/categories/iOS/"/>
    
    <category term="swift" scheme="http://jarvissky.com/categories/iOS/swift/"/>
    
    
    <category term="swift" scheme="http://jarvissky.com/tags/swift/"/>
    
    <category term="GCD" scheme="http://jarvissky.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>swift 可选值</title>
    <link href="http://jarvissky.com/2021/04/04/swift-%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    <id>http://jarvissky.com/2021/04/04/swift-%E5%8F%AF%E9%80%89%E5%80%BC/</id>
    <published>2021-04-04T09:10:51.000Z</published>
    <updated>2021-04-05T06:22:18.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift-可选值"><a href="#swift-可选值" class="headerlink" title="swift 可选值"></a>swift 可选值</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>swift 是苹果的二儿子，和大儿子OC比起来有很多优势，他更加接近现代编程语言的范式，类似解释语言的语法习惯，却是名副其实的强类型语言。接触最初就会遇到一个swift和OC明显不同的数据类型，<strong>可选值 | Optional Value</strong>。</p><p>中文翻译直接理解的话就是可以选来用也可以不选。个人认为把他理解为未定型更合符合普通的思维习惯,有点像JavaScript中的未定型。</p> <span id="more"></span><p>我们可以这样声明一个可选值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name : String?</span><br></pre></td></tr></table></figure><p>用标识符var 声明一个变量 name ，后面的？表示它是一个可选值。在后续使用中它的值可能是字符串 “张三”。也可能是一个空值 nil 。</p><p>这里有一点和OC不同的是，OC中的基本数据类型都会有默认的初始值，例如 NSInter 默认为0，CGFloat 默认为 0.0。但是swift里由于可选值概念的存在，基础数据类型（int, double, bool）没有值时也可以是nil.<br>一个可选值没有初始值的话是不可以使用的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;swift-可选值&quot;&gt;&lt;a href=&quot;#swift-可选值&quot; class=&quot;headerlink&quot; title=&quot;swift 可选值&quot;&gt;&lt;/a&gt;swift 可选值&lt;/h1&gt;&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h2&gt;&lt;p&gt;swift 是苹果的二儿子，和大儿子OC比起来有很多优势，他更加接近现代编程语言的范式，类似解释语言的语法习惯，却是名副其实的强类型语言。接触最初就会遇到一个swift和OC明显不同的数据类型，&lt;strong&gt;可选值 | Optional Value&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;中文翻译直接理解的话就是可以选来用也可以不选。个人认为把他理解为未定型更合符合普通的思维习惯,有点像JavaScript中的未定型。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://jarvissky.com/categories/iOS/"/>
    
    <category term="swift" scheme="http://jarvissky.com/categories/iOS/swift/"/>
    
    
    <category term="swift" scheme="http://jarvissky.com/tags/swift/"/>
    
    <category term="可选值" scheme="http://jarvissky.com/tags/%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jarvissky.com/2021/04/04/hello-world/"/>
    <id>http://jarvissky.com/2021/04/04/hello-world/</id>
    <published>2021-04-04T03:51:04.346Z</published>
    <updated>2021-04-05T06:10:16.637Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://jarvissky.com/tags/hexo/"/>
    
  </entry>
  
</feed>
