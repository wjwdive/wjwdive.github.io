<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jarvis的天空</title>
  
  <subtitle>闲云野鹤</subtitle>
  <link href="http://jarvissky.com/atom.xml" rel="self"/>
  
  <link href="http://jarvissky.com/"/>
  <updated>2021-11-26T14:52:21.266Z</updated>
  <id>http://jarvissky.com/</id>
  
  <author>
    <name>Jarvis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective C++ 条款10:令operator=  返回一个 reference to *this</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE10-%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE10-%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this/</id>
    <published>2021-11-26T14:51:36.000Z</published>
    <updated>2021-11-26T14:52:21.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款10-令operator-返回一个-reference-to-this"><a href="#Effective-C-条款10-令operator-返回一个-reference-to-this" class="headerlink" title="Effective C++ 条款10:令operator=  返回一个 reference to *this"></a>Effective C++ 条款10:令operator=  返回一个 reference to *this</h1><h2 id="1、连锁赋值"><a href="#1、连锁赋值" class="headerlink" title="1、连锁赋值"></a>1、连锁赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x, y, z;</span><br><span class="line">x &#x3D; y &#x3D; z &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">x &#x3D; (y &#x3D; (z &#x3D; 1));</span><br></pre></td></tr></table></figure><p>1赋值给z, z更新为1后再赋值给y, y更新为1在赋值给x。</p><span id="more"></span><p>为了实现”连锁赋值”， 赋值操作符必须返回一个 reference 志向操作符的左侧实参数。这是为class 实现赋值操作符时必须要遵循的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回类型是个 reference，指向当前对象</span><br><span class="line">Widget&amp; operator &#x3D; (const Widget&amp; rhs) &#123;</span><br><span class="line">···</span><br><span class="line">  return* this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line">&#x2F;&#x2F;这个协议适用于 +&#x3D;， -&#x3D;， *&#x3D; 等等</span><br><span class="line">Widget&amp; operator+&#x3D;(const Widget&amp; rhs) &#123;</span><br><span class="line">  ···</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此函数也适用，即使此操作符的参数类型不符合协定。</span><br><span class="line">Widget&amp; operator&#x3D;(int rhs)&#123;</span><br><span class="line">  ···</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>记住，令赋值（assignment）操作符返回一个 reference to *this.</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款10-令operator-返回一个-reference-to-this&quot;&gt;&lt;a href=&quot;#Effective-C-条款10-令operator-返回一个-reference-to-this&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款10:令operator=  返回一个 reference to *this&quot;&gt;&lt;/a&gt;Effective C++ 条款10:令operator=  返回一个 reference to *this&lt;/h1&gt;&lt;h2 id=&quot;1、连锁赋值&quot;&gt;&lt;a href=&quot;#1、连锁赋值&quot; class=&quot;headerlink&quot; title=&quot;1、连锁赋值&quot;&gt;&lt;/a&gt;1、连锁赋值&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int x, y, z;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x &amp;#x3D; y &amp;#x3D; z &amp;#x3D; 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;等同于&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x &amp;#x3D; (y &amp;#x3D; (z &amp;#x3D; 1));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1赋值给z, z更新为1后再赋值给y, y更新为1在赋值给x。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款09:绝对不在构造函数和析构函数中调用virtual函数</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE09-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE09-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-26T14:50:35.000Z</published>
    <updated>2021-11-26T14:52:12.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款09-绝对不在构造函数和析构函数中调用virtual函数"><a href="#Effective-C-条款09-绝对不在构造函数和析构函数中调用virtual函数" class="headerlink" title="Effective C++ 条款09:绝对不在构造函数和析构函数中调用virtual函数"></a>Effective C++ 条款09:绝对不在构造函数和析构函数中调用virtual函数</h1><p><strong>绝对不在构造函数和析构函数中调用virtual函数</strong></p><h2 id="1、引例子"><a href="#1、引例子" class="headerlink" title="1、引例子"></a>1、引例子</h2><p>假设你有一个 class 继承体系，用来塑膜股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志（audit log）中，也需要创建一笔适当记录。下面看起来颇为合理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;所有交易的base class </span><br><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">  Transaction();</span><br><span class="line">  virtual void logTransation() cosnt &#x3D; 0;  &#x2F;&#x2F;做出一份因类型而不同的日志记录（log entry）</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;base class 构造函数之实现</span><br><span class="line">Transaction::Transaction() &#123;</span><br><span class="line">  ···</span><br><span class="line">  logTransaction();  &#x2F;&#x2F;最后动作是志记这笔交易</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BuyTransation: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual void logTransaction() const;    &#x2F;&#x2F;志记（log）此型交易</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calss SellTransation: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual void logTransaction() const; &#x2F;&#x2F;志记（log）此型交易</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在下面这行代码执行会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无疑地会有一个 BuyTransaction 构造函数被调用，但首先 Tranactioin 构造函数一定会跟早被调用；<br>是的，derived class 对象内的base class 成分会在 derived class自身成分被构造之前先构造妥当。<br>Transaction 构造函数的最后一行调用virtual 函数 logTransaction,这正是引发惊奇的起点。<br>这时候被调用的logTransaction 是Transaction 内的版本，不是BuyTransaction 内的版本—即使目前将建立的对象类型是BuyTransacio。是的，base class构造期间 virtual  函数绝不会下降到 derived class阶层。取而代之的是，对象的作用就像隶属base 类型一样。非正式的说法或许比较传神：<strong>在base class 构造期间，virtual 函数不是virtual 函数。</strong></p><span id="more"></span><p>如果想要在基类构造函数中做一些事情，例如，一旦子类构造函数调用了基类构造函数，子类就在构造函数中记录日志<br>错误的做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;交易base class</span><br><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    Transaction();</span><br><span class="line">    virtual void logTransaction() const &#x3D; 0;    &#x2F;&#x2F;做出一份因类型不同而不同的日志记录</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数实现</span><br><span class="line">&#x2F;&#x2F;Call to pure virtual member function &#39;logTransaction&#39; has undefined behavior; overrides of &#39;logTransaction&#39; in subclasses are not available in the constructor of &#39;Transaction&#39;</span><br><span class="line">&#x2F;&#x2F;编译器提示不能在构造函数里面 调用纯虚函数，后导致不明确行为</span><br><span class="line">Transaction::Transaction() &#123;</span><br><span class="line">&#x2F;&#x2F;    logTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;derived class</span><br><span class="line">class BuyTransaction : public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;derived class</span><br><span class="line">class SellTransaction: public Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;    &#x2F;&#x2F;记录log</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;条款09: 绝不在构造函数和析构函数中调用virtual函数\n&quot;;</span><br><span class="line">    </span><br><span class="line">    BuyTransaction b;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正确的做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;解决方法，要想在derived class 创建的时候自动记录日志，可以这样,在class Transaction 内将logTransaction 函数改为non-virtual,然后要求derived class 构造函数传递必要信息给 transactionPro构造函数，而后那个构造函数便可安全地调用 non-virtual logTransactionPro.</span><br><span class="line"></span><br><span class="line">class TransactionPro &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit TransactionPro(const string&amp; logInfo);</span><br><span class="line">    void logTransaction(const string&amp; logInfo) const;   &#x2F;&#x2F; non-virtual 函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TransactionPro::TransactionPro(const string&amp; logInfo) &#123;</span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TransactionPro::logTransaction(const string&amp; logInfo) const&#123;</span><br><span class="line">    cout&lt;&lt; &quot; logTransaction &quot; &lt;&lt; logInfo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTransactionPro: public TransactionPro &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;子类通过构造时传递参数，使得基类能够在构造时获取该参数（static 函数返回参数的方式）</span><br><span class="line">    BuyTransactionPro(const string&amp; logInfo): TransactionPro(createLogString(logInfo))&#123;</span><br><span class="line">        &#x2F;&#x2F;。。。</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static string createLogString(const string&amp; logInfo);&#x2F;&#x2F;static 函数，保证</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string BuyTransactionPro::createLogString (const string&amp; logInfo) &#123;</span><br><span class="line">    cout &lt;&lt; &quot; createLogString &quot;&lt;&lt; logInfo &lt;&lt; endl;</span><br><span class="line">    return logInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;由于无法使用virtual函数从 base class 向下调用，在构造期间，你可以藉由“令 derived classes 将必要的构造信息向上传递至 base class  构造函数” 替换之而加以弥补。</span><br><span class="line">&#x2F;&#x2F;本例中 BuyTransaction 内的private static 函数createLogString的运用。比起在成员初值列内给予base class 所需数据，利用辅助函数创建一个 值传给base class 构造函数往往比较方便。令此函数为static,也就不可能意外指向“初期未成熟之 BuyTransaction 对象内尚未初始化的成员变量”。</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;条款09: 绝不在构造函数和析构函数中调用virtual函数\n&quot;;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    BuyTransaction b;</span><br><span class="line">    const string&amp; s1(&quot;buyLog&quot;);</span><br><span class="line">    BuyTransactionPro btp(s1);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">条款09: 绝不在构造函数和析构函数中调用virtual函数</span><br><span class="line"> createLogString buyLog</span><br><span class="line"> logTransaction buyLog</span><br><span class="line">Program ended with exit code: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款09-绝对不在构造函数和析构函数中调用virtual函数&quot;&gt;&lt;a href=&quot;#Effective-C-条款09-绝对不在构造函数和析构函数中调用virtual函数&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款09:绝对不在构造函数和析构函数中调用virtual函数&quot;&gt;&lt;/a&gt;Effective C++ 条款09:绝对不在构造函数和析构函数中调用virtual函数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;绝对不在构造函数和析构函数中调用virtual函数&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、引例子&quot;&gt;&lt;a href=&quot;#1、引例子&quot; class=&quot;headerlink&quot; title=&quot;1、引例子&quot;&gt;&lt;/a&gt;1、引例子&lt;/h2&gt;&lt;p&gt;假设你有一个 class 继承体系，用来塑膜股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志（audit log）中，也需要创建一笔适当记录。下面看起来颇为合理：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;所有交易的base class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Transaction &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Transaction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  virtual void logTransation() cosnt &amp;#x3D; 0;  &amp;#x2F;&amp;#x2F;做出一份因类型而不同的日志记录（log entry）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;base class 构造函数之实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Transaction::Transaction() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  logTransaction();  &amp;#x2F;&amp;#x2F;最后动作是志记这笔交易&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class BuyTransation: public Transaction &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  virtual void logTransaction() const;    &amp;#x2F;&amp;#x2F;志记（log）此型交易&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;calss SellTransation: public Transaction &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  virtual void logTransaction() const; &amp;#x2F;&amp;#x2F;志记（log）此型交易&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;现在下面这行代码执行会发生什么？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BuyTransaction b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;无疑地会有一个 BuyTransaction 构造函数被调用，但首先 Tranactioin 构造函数一定会跟早被调用；&lt;br&gt;是的，derived class 对象内的base class 成分会在 derived class自身成分被构造之前先构造妥当。&lt;br&gt;Transaction 构造函数的最后一行调用virtual 函数 logTransaction,这正是引发惊奇的起点。&lt;br&gt;这时候被调用的logTransaction 是Transaction 内的版本，不是BuyTransaction 内的版本—即使目前将建立的对象类型是BuyTransacio。是的，base class构造期间 virtual  函数绝不会下降到 derived class阶层。取而代之的是，对象的作用就像隶属base 类型一样。非正式的说法或许比较传神：&lt;strong&gt;在base class 构造期间，virtual 函数不是virtual 函数。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款08:别让异常逃离析构函数</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE08-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE08-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-26T14:48:58.000Z</published>
    <updated>2021-11-26T14:50:55.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款08-别让异常逃离析构函数"><a href="#Effective-C-条款08-别让异常逃离析构函数" class="headerlink" title="Effective C++ 条款08:别让异常逃离析构函数"></a>Effective C++ 条款08:别让异常逃离析构函数</h1><h2 id="1、C-并不禁止析构函数吐出异常，但它并不鼓励你这样做。"><a href="#1、C-并不禁止析构函数吐出异常，但它并不鼓励你这样做。" class="headerlink" title="1、C++并不禁止析构函数吐出异常，但它并不鼓励你这样做。"></a>1、C++并不禁止析构函数吐出异常，但它并不鼓励你这样做。</h2><p>通过一个例子说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">  ···</span><br><span class="line">  ～Widget()&#123;···&#125;&#x2F;&#x2F;假设这个析构函数可能吐出异常</span><br><span class="line">&#125;;</span><br><span class="line">void doSomethind() &#123;</span><br><span class="line">  std::vector&lt;Widget&gt; v;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;v 在这里被自动销毁</span><br></pre></td></tr></table></figure><p>当vector v被销毁，它有责任销毁其内含的所有Widget。假设 v 内含十个Widgets， 而在析构函数第一个元素期间，有个异常被抛出。</p><span id="more"></span><p>其它9个也应该被销毁（否则它们保存的任何资源都会发生泄露），因此v应该调用他们各个析构函数。但假设在那些调用期间，第二个Widget析构函数又抛出异常。<br>现在同时有两个异常，这对C++很常见，但是两个异常同时存在会导致不明确行为。<br>其他程序库的任何容器如list,set或 TR1的任何容器或甚至array。也会出现相同的情况。</p><p>总之，C++不喜欢在析构函数突出异常。</p><p>但是如果你的析构函数必须执行一个动作，而该动作会在失败时抛出异常。<br>例如：假设你使用一个class 负责数据库链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DBConnection &#123;</span><br><span class="line">public:</span><br><span class="line">  ···</span><br><span class="line">  static DBConnection create();    &#x2F;&#x2F;这个函数返回 DBConnection 对象</span><br><span class="line">  void close();                            &#x2F;&#x2F;关闭联机，失败则抛出异常</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为确保客户不忘记在DBConnection 对象身上调用close(), 一个合理的想法是创建一个来管理DBConnection 资源的class,并在其析构函数中调用close。<br>这一类用于资源管理的classes 在条款3中有讨论。这里只考虑析构函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这个class 用来管理DBConnection对象</span><br><span class="line">class DBConnection &#123;</span><br><span class="line">public:</span><br><span class="line">  ···</span><br><span class="line">  ～DBConn()&#123;    &#x2F;&#x2F;确保数据库连接总会被关闭</span><br><span class="line">    db.close();</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这个管理类，客户就可能这样写代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;开启一个区块，建立DBConnection 对象并交给DBConn 对象管理，通过DBConn的接口使用DBConnection对象。在区块结束点，DBConn对象被销毁，因而自动为DBConnection对象 调用close</span><br><span class="line">DBConn dbc(DBConnection::create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要调用close成功，一切都美好。如果调用导致异常，DBConn析构函数会传播该异常，也就是允许它允许离开这个析构函数。那会造成问题，因为那就是抛出了难以驾驭的麻烦。<br>两个办法可以避免这个问题。DBConn的析构函数可以：<br>-<strong>如果close 抛出异常就结束程序，通常通过调用abort完成：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn() </span><br><span class="line">&#123;</span><br><span class="line">try &#123; db.close(); &#125;</span><br><span class="line">catch(···) &#123;</span><br><span class="line">  &#x2F;&#x2F;制作运转记录，记下对close 的调用失败</span><br><span class="line">  std::abort();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序遭遇一个”于析构期间发生的错误”后续无法继续执行，”强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去（那会导致不明确行为）。也就是调用abort可以抢先制”不明确行为”于死地。</p><ul><li><strong>吞下因调用close而发生的异常</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DBconn::~DBConn() &#123;</span><br><span class="line">  try&#123; db.close(); &#125;</span><br><span class="line">  catch(···) &#123;</span><br><span class="line">    &#x2F;&#x2F;制作运转记录，记下对close的调用失败；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>一般而言，将异常吞掉是个坏注意，因为它压制了”某些动作失败”的重要信息！！然而有时候吞下异常也比负担”草率结束程序”或‘“不明确行为带来的风险”好。为了让这策划功能为一个可行的方案，程序必须能够继续可靠地执行，即使在遭遇并忽略一个错误之后。<br>这些办法都还可以。但是问题是两者都无法对”导致clsoe 抛出异常”的情况作出反应。</li></ul><p>一个较佳饿策略是重新设计DBConn接口，使其客户有机会对可能出现的问题作出反应。例如DBConn 自己可以提供一个close函数，因而赋予可以一个机会得以处理”因该操作而发生的异常”。DBConn也可以追踪其所管理的 DBConnection 是否已被关闭，并在答案为 否 的情况下由其析构函数关闭之。这可防止遗失数据库链接。<br>然而如果DBConnection析构函数调用clsoe失败，我们又可以将退回”强迫结束程序”或”吞下异常”的老路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class DBConn &#123;</span><br><span class="line">public:</span><br><span class="line">  void close() &#123;        &#x2F;&#x2F;供客户使用的新函数</span><br><span class="line">    db.close();</span><br><span class="line">    closed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  ～DBConn() &#123;</span><br><span class="line">    if(!closed) &#123;</span><br><span class="line">      try&#123;        &#x2F;&#x2F;关闭链接</span><br><span class="line">          db.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch(···) &#123;&#x2F;&#x2F;如果关闭动作失败，记录下来并结束程序或吞下异常</span><br><span class="line">      &#x2F;&#x2F;制作运作记录，记下对close 的调用失败；</span><br><span class="line">      ···</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  DBConnection db;</span><br><span class="line">  bool closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把调用close的责任从DBConn析构函数手上移到 DBConn 客户手上（但DBConn析构函数仍内含一个 “双保险”调用）可能会给你”是无忌惮转移负担”的印象。<br>你甚至可能认为它违反条款18,(让接口容易被正确使用)。<br>实际不是这样的，针对某个可能存在抛出异常的操作，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数函数以外的某个函数。<br><strong>因为析构函数吐出异常就是危险。总会带来”过早结束程序”或”发生不明确行为”的风险。</strong><br>本例要说的是，由客户自己调用close 并不会对他们带来负担，而是给他们一个处理错误的机会，否则他们没机会响应。<br>如果客户不认为这个机会有用，可以忽略它，依赖DBConn析构函数去调用close。如果真的有错误发生，如果close的确跑抛出异常，而且DBConn吞下异常或结束程序，客户没有立场抱怨，毕竟他们曾经有一次机会第一手处理问题，而他们选择了放弃。</p><p>总结</p><ul><li>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数函数应该捕捉任何异常，然后吞下他们或者结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款08-别让异常逃离析构函数&quot;&gt;&lt;a href=&quot;#Effective-C-条款08-别让异常逃离析构函数&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款08:别让异常逃离析构函数&quot;&gt;&lt;/a&gt;Effective C++ 条款08:别让异常逃离析构函数&lt;/h1&gt;&lt;h2 id=&quot;1、C-并不禁止析构函数吐出异常，但它并不鼓励你这样做。&quot;&gt;&lt;a href=&quot;#1、C-并不禁止析构函数吐出异常，但它并不鼓励你这样做。&quot; class=&quot;headerlink&quot; title=&quot;1、C++并不禁止析构函数吐出异常，但它并不鼓励你这样做。&quot;&gt;&lt;/a&gt;1、C++并不禁止析构函数吐出异常，但它并不鼓励你这样做。&lt;/h2&gt;&lt;p&gt;通过一个例子说明&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Widget &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ～Widget()&amp;#123;···&amp;#125;&amp;#x2F;&amp;#x2F;假设这个析构函数可能吐出异常&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void doSomethind() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  std::vector&amp;lt;Widget&amp;gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;v 在这里被自动销毁&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当vector v被销毁，它有责任销毁其内含的所有Widget。假设 v 内含十个Widgets， 而在析构函数第一个元素期间，有个异常被抛出。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款07:为多态基类声明virtual 析构函数</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE07-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE07-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-26T14:47:32.000Z</published>
    <updated>2021-11-26T14:49:51.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。"><a href="#C-实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。" class="headerlink" title="C++实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。"></a>C++实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。</h1><h3 id="1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现"><a href="#1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现" class="headerlink" title="1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现"></a>1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现</h3><p>C++ 明确指出：当派生类对象经由一个base calss 指针被删除，而该base class 带着一个non-virtual 析构函数，其结果未有定义–实际执行时通常繁盛的是对象的派生成分没有被销毁。也就是这样做派生类的成员变量很可能没有被销毁，而派生类的析构函数也没有执行。但是基类的成分，通常被销毁，于是造成诡异的局部销毁对象。这可能造成资源泄漏、败坏数据结构，在调试器上浪费许多时间。<br>消除这个问题的做法很简单：就是给 base class 一个虚析构函数。此后删除derived class 对象就会如你想要的那般，它会销毁整个对象，包括所有的derived class成分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TimeKeeper</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();  <span class="comment">//base class  声明虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line">TimerKeeper *ptk = <span class="built_in">getTimeKeeper</span>();</span><br><span class="line">···</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure><p>像TimerKeeper 这样的base classes 除了析构函数之外，通常还有其他 virtual函数，因为virtual函数的目的是允许 derived class 的实现得以客制化【34】。<br>例如 TimerKeeper 可能拥有一个 virtual getCurrentTime, 它在不同的 derived class 中 有不同的实现代码。任何class 只要带有 virtual函数几乎确定应该也有一个 virtual 析构阿函数。</p><span id="more"></span><h3 id="2、永远令析构函数为虚函数也在和C语言切换的时候也会出问题"><a href="#2、永远令析构函数为虚函数也在和C语言切换的时候也会出问题" class="headerlink" title="2、永远令析构函数为虚函数也在和C语言切换的时候也会出问题"></a>2、永远令析构函数为虚函数也在和C语言切换的时候也会出问题</h3><p>如果class 不含 virtual 函数，通常表示它并不意图被用做一个 base class。当 class不被当作base class，令其析构函数 为virtual往往是一个馊主意。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">public:</span><br><span class="line">  Point(int xCoord, int yCoord);</span><br><span class="line">  ~Point();</span><br><span class="line">private:</span><br><span class="line">  int x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 int 占用 32bits,那么 Point 对象可塞入一个 64-bit 缓存器中。更有甚者，这样一个Point对象可能被当作一个 “64-bit量”传给其他语言，如C 或者 FORTRAN撰写的函数。然而，当Point的析构函数是virtual ，形势起了变化。</p><p>欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual 函数被调用。这份信息通常是由一个所谓vptr（virtual table pointer）指针指出。<br>vprt只想一个由函数指针构成的数组，称为 vtbl(virtual table);每一个带有virtual 函数的class都有一个相应的vtbl.当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl—-编译器在其中寻找适当的函数指针。</p><p>如果Point class内含virtual函数，其对象的体积会增加：在 32-bit 计算机体系结构中将占用 64bits（为了存放两个int）至 96 bits（两个int + vptr）;<br>在64-bit计算机体系结构中可能占用64～128bits， 因为指针在这样的计算机结构中占64-bits.因此，为Point添加一个vprt会增加对象大小达50%～100%！Point对象不能再能够塞入一个 64-bits的缓存器，而C++的Point对象也不再和其他语言如C,内的相同声明有着一样的结构（因为其他语言的对应物并没有vptr），因此也就不能再可能把它传递至（或接受自）其他语言所写的函数，除非你明确补偿vprt—-那属于实现细节，也因此不再具有移植性。</p><p>因此，无端地将所有classes的析构函数声明为virtual，就像未声明他们为virtual一样，都是错误的。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。</p><h3 id="3、即使class完全不带virtual函数，被non-virtual析构函数问题折腾还是有可能的"><a href="#3、即使class完全不带virtual函数，被non-virtual析构函数问题折腾还是有可能的" class="headerlink" title="3、即使class完全不带virtual函数，被non-virtual析构函数问题折腾还是有可能的"></a>3、即使class完全不带virtual函数，被non-virtual析构函数问题折腾还是有可能的</h3><p>例如： 标准string不含任何virtual函数，但有时候程序员会错误的把它当作base class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;馊主意！std::string 有个 non-virtual析构函数</span><br><span class="line">class SpecialString: public std::string &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样看似没有问题，但是如果你这样做，无意间将一个 pointer-to-SpecialString转换为一个 pointer-to-string，然后将转换所得的那个string指针delete掉，你立刻被流放到”行为不明确”的冥界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpecialString *sps &#x3D; new SpecialString(&quot;Impending Doom&quot;);</span><br><span class="line">std:: sgtring *ps;</span><br><span class="line">···</span><br><span class="line">ps &#x3D; pps;  &#x2F;&#x2F;SpecialString * &#x3D;&gt; std::string*</span><br><span class="line">···</span><br><span class="line">delete ps;  &#x2F;&#x2F;未有定义！现实中 *ps 的 SpecialString 资源会泄漏，因为SpecialString 析构函数没有被调用</span><br></pre></td></tr></table></figure><p>相同的分析适用于任何不带virtual 析构函数的class,包括 STL 容器如： vector, list, set, trl::unordered_map【54】等等。如果你曾经企图继承一个标准容器或者其他任何”带有non-virtual析构函数”的class，拒绝诱惑，C++没有类似java的final classes 或 sealed classes那样的”禁止派生”机制。</p><p>有时候class带一个 pure virtual函数，可能颇为顺利。还记得吗？pure virtual 函数导致abstract (抽象)classes —-也就是不能被实体化（instantiated）的class。<br>也就是说，你不能为那种类型创建对象。然而有时候你希望拥有抽象class，但手上没有任何pure virtual函数，怎么办。由于抽象class总是企图被当作一个base class来用，因此解法很简单： 为你希望他成为抽象的那个class 声明一个 pure virtual析构函数。具体例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Abstract Virtuals</span><br><span class="line">class AWOV &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~AWOV() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个class 又一个pure virtual 函数，所以它是个抽象class, 又由于它有个 virtual 析构函数，所以你不需要担心析构函数的问题。然而这里又有一个窍门：你必须为这个pure virtual 析构函数提供一份定义：<br>AWOV::~AWOV() {};//pure virtual 析构函数的定义<br>析构函数的运作方式是，最深层派生（魔术贴 derived）的那个class 起析构函数是先被调用，然后其每一base class 的析构函数被调用。编译器会在 AWOV的derived class的析构函数中常见一个对～AWOV()的调用动作，所以你必须为这个函数提供一份定义。如果不这样做，连接器会发生抱怨。</p><p>“给base classes 一个 virtual 析构函数”，这个规则只适用于polymorphic(带多太性质的)base classes身上。这种base classes的设计目的是为了用来””通过base class 接口处理 derived class 对象”。TimeKeeper 就是一个 polymorphic base class,因为我们希望处理 AtomincClock 和 WaterClock 对象，纵使我们只有timeKeeper 指针指向它们。</p><p>并非所有的base classes的设计目的都是为了多态用途。例如 string和STL 容器都不被设计作为base classes使用，更别提多态的。某些classes的设计目的是作为base classes使用，但不是为了多态用途。这样的classes如【条款6】的Uncopyable和标准程序库的input_iterator_tag(【条款47】)，它们并非被设计用来”经由base class”接口处置 derived class 对象，因此他们不需要virtual 析构函数。</p><p>-多态性质的base classes 应该声明一个virtual析构函数，如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。<br>-Classes的设计目的如果不是作为base classes使用，或不是为了具备多台性质，就不该声明为virtual析构函数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。&quot;&gt;&lt;a href=&quot;#C-实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。&quot; class=&quot;headerlink&quot; title=&quot;C++实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。&quot;&gt;&lt;/a&gt;C++实现多态的时候经常用的一招是父类指针指向子类对象，在继承关系中可能出现错误。&lt;/h1&gt;&lt;h3 id=&quot;1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现&quot;&gt;&lt;a href=&quot;#1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现&quot; class=&quot;headerlink&quot; title=&quot;1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现&quot;&gt;&lt;/a&gt;1、基类的析构函数不是虚函数时候可能会有子类实例对象不被完全销毁的问题出现&lt;/h3&gt;&lt;p&gt;C++ 明确指出：当派生类对象经由一个base calss 指针被删除，而该base class 带着一个non-virtual 析构函数，其结果未有定义–实际执行时通常繁盛的是对象的派生成分没有被销毁。也就是这样做派生类的成员变量很可能没有被销毁，而派生类的析构函数也没有执行。但是基类的成分，通常被销毁，于是造成诡异的局部销毁对象。这可能造成资源泄漏、败坏数据结构，在调试器上浪费许多时间。&lt;br&gt;消除这个问题的做法很简单：就是给 base class 一个虚析构函数。此后删除derived class 对象就会如你想要的那般，它会销毁整个对象，包括所有的derived class成分。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TimeKeeper&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;TimeKeeper&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;built_in&quot;&gt;TimeKeeper&lt;/span&gt;();  &lt;span class=&quot;comment&quot;&gt;//base class  声明虚析构函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TimerKeeper *ptk = &lt;span class=&quot;built_in&quot;&gt;getTimeKeeper&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; ptk;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;像TimerKeeper 这样的base classes 除了析构函数之外，通常还有其他 virtual函数，因为virtual函数的目的是允许 derived class 的实现得以客制化【34】。&lt;br&gt;例如 TimerKeeper 可能拥有一个 virtual getCurrentTime, 它在不同的 derived class 中 有不同的实现代码。任何class 只要带有 virtual函数几乎确定应该也有一个 virtual 析构阿函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款06:若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE06-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE06-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</id>
    <published>2021-11-26T14:46:10.000Z</published>
    <updated>2021-11-26T14:49:45.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款06-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#Effective-C-条款06-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="Effective C++ 条款06:若不想使用编译器自动生成的函数，就该明确拒绝"></a>Effective C++ 条款06:若不想使用编译器自动生成的函数，就该明确拒绝</h1><h2 id="1、如何禁止编译器自动生成复制构造函数"><a href="#1、如何禁止编译器自动生成复制构造函数" class="headerlink" title="1、如何禁止编译器自动生成复制构造函数"></a>1、如何禁止编译器自动生成复制构造函数</h2><p>有些时候，我们需要的对象全局只保留一份。那么我们设计类的时候就不能让该类支持复制出另一个出来。<br>例如：一个地产中介软件系统中，必有一个class 用来描述代售房屋：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class HomeForSale&#123;  ···   &#125;;</span><br></pre></td></tr></table></figure><p>该类逻辑上就不能被拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HomeForSale h1;</span><br><span class="line">HomeForSale h2;</span><br><span class="line">HomeForSale h3(h1);      &#x2F;&#x2F;企图拷贝h1-- 不应该通过编译</span><br><span class="line">h1 &#x3D; h2;                        &#x2F;&#x2F;企图拷贝h2-- 不应该通过编译</span><br></pre></td></tr></table></figure><h3 id="1-1-我们该如何阻止编译器合成拷贝构造函数？"><a href="#1-1-我们该如何阻止编译器合成拷贝构造函数？" class="headerlink" title="1.1 我们该如何阻止编译器合成拷贝构造函数？"></a>1.1 我们该如何阻止编译器合成拷贝构造函数？</h3><p>由于C++会自动合成四个基本函数，所以我们就算不声明拷贝构造函数，编译器也会自动给合成。<br>我们该如何阻止内？<br>由于所有编译器产出的函数都是public。为阻止这些函数被创建出来，你得自行声明他们，但这里并没有什么需求使你必须将他们声明为public。<br>因此你可以将 copy 构造函数 或 copy assignment 操作符声明为 private。<br>这样，籍由明确声明一个成员函数就阻止了编译器自创其专属版本，而且令这些函数为private,使你得以成功阻止人们调用它。</p><span id="more"></span><h3 id="1-2-private-的局限"><a href="#1-2-private-的局限" class="headerlink" title="1.2 private 的局限"></a>1.2 private 的局限</h3><p>一般来说，这个做法并不绝对安全，因为 member 函数 和 friend函数还是可以调用 你的private函数。如果有人不慎调用任何一个，会获得一个连接错误（linkage error）。<br><strong>将成员函数声明为private 而且故意不实现他们</strong> 这一伎俩是如此被大众接受，因而被用在C++  iostream 程序库中阻止copying 行为。<br>例如，很多标准程序库的实现代码中， ios_base, basic_ios和sentry。都会发现，其copy 构造函数和 copy assignment 操作符都被声明为 private,而且没有定义。</p><p>对HomeForSale类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class HomeForSale &#123;</span><br><span class="line">public:</span><br><span class="line">  ···</span><br><span class="line">private:</span><br><span class="line">  ···</span><br><span class="line">  HomeForSale(const HomeForSale&amp;);                &#x2F;&#x2F;只有声明</span><br><span class="line">  HomeForSale&amp; operator&#x3D;(const HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例子没有写函数的参数名称。不被实现的情况下，可以这样写。<br>有了上述class 定义，当客户企图拷贝 HomeForSale对象，编译器阻止这一行为。如果你不慎在member函数或friend函数之内那么做，轮到连接器发出抱怨。</p><p>将连接器错误移至编译期是可能的（而且那是好事，毕竟越早发现错误越好），只要将copy构造函数和 copy assignment 操作符声明为private就可以办到，但不是在 HomeForSale 自身，而是专门设计一个base class阻止copying 动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Uncopyable &#123;</span><br><span class="line">protected:        &#x2F;&#x2F;允许derived对象的构造和析构</span><br><span class="line">  Uncopyable()&#123;&#125;</span><br><span class="line">  ~Uncopyable()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">  Uncopyable(const Uncopyable&amp;);  &#x2F;&#x2F;阻止copying</span><br><span class="line">  Uncopyable&amp; operator&#x3D;(const Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为阻止 HomeForSale对象被拷贝，我们唯一需要做的就是继承Uncopyable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class HomeForSale: private Uncopyable &#123;</span><br><span class="line">&#x2F;&#x2F;class 不再声明copy构造函数或copy assign操作符</span><br><span class="line">···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样行得通，只要任何人—-甚至是member 函数或friend函数—-尝试拷贝HomeForSale对象，编译器便试着生成一个copy 构造函数和一个 copy assignment 操作符。</p><p>Uncopyable class 的实现和运用颇为微妙，包括不一定得以public  继承它，以及Uncopyable的析构 函数不一定是virtual等等。<br>Uncopyable不含数据，这符合条款39所描述的 empty base class optimization资格。<br>但是由于它总是扮演base class, 因此使用这项技术可能导致多重继承。<br>条款55 中Boost提供的版本。也可以解决该问题。</p><p><strong>为阻止编译器自动合成一些函数，可将相应的成员函数声明为private并且不予实现</strong><br><strong>为阻止编译器自动合成一些函数，也可使用 uncopyable 这样的base class</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款06-若不想使用编译器自动生成的函数，就该明确拒绝&quot;&gt;&lt;a href=&quot;#Effective-C-条款06-若不想使用编译器自动生成的函数，就该明确拒绝&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款06:若不想使用编译器自动生成的函数，就该明确拒绝&quot;&gt;&lt;/a&gt;Effective C++ 条款06:若不想使用编译器自动生成的函数，就该明确拒绝&lt;/h1&gt;&lt;h2 id=&quot;1、如何禁止编译器自动生成复制构造函数&quot;&gt;&lt;a href=&quot;#1、如何禁止编译器自动生成复制构造函数&quot; class=&quot;headerlink&quot; title=&quot;1、如何禁止编译器自动生成复制构造函数&quot;&gt;&lt;/a&gt;1、如何禁止编译器自动生成复制构造函数&lt;/h2&gt;&lt;p&gt;有些时候，我们需要的对象全局只保留一份。那么我们设计类的时候就不能让该类支持复制出另一个出来。&lt;br&gt;例如：一个地产中介软件系统中，必有一个class 用来描述代售房屋：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class HomeForSale&amp;#123;  ···   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该类逻辑上就不能被拷贝。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HomeForSale h1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HomeForSale h2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HomeForSale h3(h1);      &amp;#x2F;&amp;#x2F;企图拷贝h1-- 不应该通过编译&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h1 &amp;#x3D; h2;                        &amp;#x2F;&amp;#x2F;企图拷贝h2-- 不应该通过编译&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;1-1-我们该如何阻止编译器合成拷贝构造函数？&quot;&gt;&lt;a href=&quot;#1-1-我们该如何阻止编译器合成拷贝构造函数？&quot; class=&quot;headerlink&quot; title=&quot;1.1 我们该如何阻止编译器合成拷贝构造函数？&quot;&gt;&lt;/a&gt;1.1 我们该如何阻止编译器合成拷贝构造函数？&lt;/h3&gt;&lt;p&gt;由于C++会自动合成四个基本函数，所以我们就算不声明拷贝构造函数，编译器也会自动给合成。&lt;br&gt;我们该如何阻止内？&lt;br&gt;由于所有编译器产出的函数都是public。为阻止这些函数被创建出来，你得自行声明他们，但这里并没有什么需求使你必须将他们声明为public。&lt;br&gt;因此你可以将 copy 构造函数 或 copy assignment 操作符声明为 private。&lt;br&gt;这样，籍由明确声明一个成员函数就阻止了编译器自创其专属版本，而且令这些函数为private,使你得以成功阻止人们调用它。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款05:了解C++默默编写并调用了那些函数</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE05-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE05-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-26T14:44:56.000Z</published>
    <updated>2021-11-26T14:45:44.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款05-了解C-默默编写并调用了那些函数"><a href="#Effective-C-条款05-了解C-默默编写并调用了那些函数" class="headerlink" title="Effective C++ 条款05:了解C++默默编写并调用了那些函数"></a>Effective C++ 条款05:了解C++默默编写并调用了那些函数</h1><h2 id="1、众所周知C-的一个类中是有4个核心函数的"><a href="#1、众所周知C-的一个类中是有4个核心函数的" class="headerlink" title="1、众所周知C++的一个类中是有4个核心函数的"></a>1、众所周知C++的一个类中是有4个核心函数的</h2><p>构造函数，析构函数，拷贝构造函数，赋值构造函数。<br>而且一个空类，class内部什么都不做C++默认都会合成这写核心函数，当然是这些函数被调用的时候，他们才会被编译器创建出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;下面的写法和上面效果一样：</span><br><span class="line">class Empty &#123;</span><br><span class="line">public: </span><br><span class="line">  Empty()&#123;···&#125;                              &#x2F;&#x2F;default 构造函数</span><br><span class="line">  Empty(const Empty&amp; rhs) &#123;···&#125;    &#x2F;&#x2F;copy构造函数</span><br><span class="line">  ~Empty() &#123; ··· &#125;                         &#x2F;&#x2F;析构函数</span><br><span class="line"></span><br><span class="line">  Empty&amp; operator&#x3D;(const Empty&amp; rhs) &#123; ··· &#125;&#x2F;&#x2F;copy assignment 操作符号</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果是一个空类，下面的代码会造成上面的函数被编译器创建</span><br><span class="line">Empty e1;      &#x2F;&#x2F;default 构造函数</span><br><span class="line">                    &#x2F;&#x2F;析构函数</span><br><span class="line">Empty e2(e1);&#x2F;&#x2F;copy构造函数</span><br><span class="line">e2 &#x3D; e1;        &#x2F;&#x2F;copy assignment 操作符号</span><br></pre></td></tr></table></figure><h3 id="1-1-构造函数、析构函数是干嘛用的？"><a href="#1-1-构造函数、析构函数是干嘛用的？" class="headerlink" title="1.1 构造函数、析构函数是干嘛用的？"></a>1.1 构造函数、析构函数是干嘛用的？</h3><p>构造函数、析构函数主要是给编译器一个地方用来放置”藏身幕后”的代码，像是调用base classed  和 non-static 成员变量的构造函数和析构函数。<br>⚠️注意：编译器产出的析构函数是个 non-virtual 的，除非这个 class 的base class 自身声明有virtual 析构函数（这种情况下这个函数的虚属性主要来自bsae class）</p><span id="more"></span><h3 id="1-2-copy构造函数-和-copy-assignment操作符号，编译器创建的版本只是单纯地将来源对象的每一个-non-static-成员变量拷贝到目标对象。"><a href="#1-2-copy构造函数-和-copy-assignment操作符号，编译器创建的版本只是单纯地将来源对象的每一个-non-static-成员变量拷贝到目标对象。" class="headerlink" title="1.2 copy构造函数 和 copy assignment操作符号，编译器创建的版本只是单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象。"></a>1.2 copy构造函数 和 copy assignment操作符号，编译器创建的版本只是单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象。</h3><p>例如一个 NamedObject temlpate, 它允许你将一个个名称和类型为T的对象产生关联：<br>template<typename T><br>class NamedObject {<br>public:<br>  NamedObject(const char* name, const T&amp; value);<br>  NamedObject(const std::string&amp; name, const T&amp; value);<br>  ···<br>private：<br>  std::string nameValue;<br>  T objectValue;<br>};<br>代码分析：由于类中声明了一个构造函数，编译器于是不再为它创建default构造函数。<br>这很重要，这样的的话，编译器看你自己创建了一个有参数的构造函数，自己就不再生成默认无实参数的版本，不会覆盖你创建的构造函数。</p><p>NamedObject 既没有声明copy 构造函数，也没有声明 copy assignment 操作符，所以编译器会为它创建那些函数（如果它们被调用的话）<br>。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2);</span><br><span class="line">NamedObject&lt;int&gt; no2(no1);            &#x2F;&#x2F;调用copy构造函数</span><br></pre></td></tr></table></figure><p>编译器生成的copy 构造函数必须以 no1.nameValue 和 no1.objectValue 为初始值 设定 no2.nameValue 和 no2.objectValue。<br>两者中的 nameValue类型是string，而标准的 string 有一个 copy构造函数，所以 no2.nameValue的初始化方式是调用 string 的copy 构造函数并以no1.nameValue 为实参。<br>另一个成员NamedObject<int>::objectValue 的类型是int(因为对此template 具体而言 T 是int), 那是个内置类型，所以 no2.objectValue会以”拷贝no1.objectValue 内的每一个bits “来完成初始化。</p><p>编译器为NamedValue<int>  所生成的copy assignment 操作符号，其行为基本上与copy 构造函数如出一辙，但一般而言只有当生出的代码合法且有适当机会证明它有意义，其表现才会如我们先前所说。万一两个条件有一个不符合，编译器会拒绝为class生出 operator=.</p><ul><li><strong>成员为 reference to string</strong></li><li><strong>成员中有 const T</strong><br>例如：nameValue 是个 reference to string, objectValue 是个const T:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class NamedObject &#123;</span><br><span class="line">public:</span><br><span class="line">  &#x2F;&#x2F;一下构造函数如今不再接受一个const 名称，因为nameValue 如今是个 reference-to-non-const string。先前那个char * 构造函数已经过去了，因为必须有个 string 可供指涉。</span><br><span class="line">  NamedObject(std::string&amp; name, const T&amp; value);</span><br><span class="line">  ···                            &#x2F;&#x2F;如前，假设并未声明 operator&#x3D;</span><br><span class="line">private:</span><br><span class="line">  std::string&amp; nameValue;&#x2F;&#x2F;这如今是个reference </span><br><span class="line">  const T objectValue;    &#x2F;&#x2F;这如今是个cosnt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;考虑以下代码</span><br><span class="line">std::string newDog(&quot;小狗&quot;)；</span><br><span class="line">std::string oldDog(&quot;老狗&quot;)；</span><br><span class="line">NamedObject&lt;int&gt; sd(newDog, 2);  &#x2F;&#x2F; 当初撰写至此，我们的小狗是两岁</span><br><span class="line">NamedObject&lt;int&gt; bd(oldDog, 36);  &#x2F;&#x2F;老狗是36岁</span><br><span class="line">p &#x3D; s;        &#x2F;&#x2F;  现在会发生什么？？？</span><br><span class="line"></span><br></pre></td></tr></table></figure>赋值之前，不论p.nameValue 和 s.nameValue 都指向string对象（当然不是同一个）。赋值动作该如何影响 p.nameValue呢？<br>赋值之后 p.nameValue应该是指向 s.nameValue 所指的那个string 吗？</li></ul><p><strong>也就是说 reference 自身可被改动吗？</strong><br><strong>答案是 C++ 不允许”让reference 改指不同对象”</strong></p><p>换个想法，p.nameValue 所指的那个 string对象被修改，进而影响”持有pointers 或 references 而且指向该 string” 的其他对象吗？<br>也就是对象不被直接牵扯到赋值操作内？<br>编译器生成的copy assignment 操作符究竟该怎么办？</p><p>这一难题，C++编译器的做法是拒绝编译哪一行赋值动作。<br>如果你打算在一个”内含reference 成员”的class 内支持赋值操作（assignment）,你必须自己定义copy assignment 操作符。<br>面对”内含const 成员”（如本例子中的 objectValue）的classes,编译器的反应也是一样的。更改const 成员是不合法的，所以编译器不知道如何在它自己生成的赋值函数内面对它们。<br>最后还有一种情况：如果某个base classes 将 copy assignment 操作符声明为private，编译器拒绝为其 derived classes 生成一个copy assignment操作符。毕竟编译器为derived classed 所生成的 copy assignment 操作符想象中可以处理 base classes 成分，但它们当然无法调用 derived class无权调用的成员函数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款05-了解C-默默编写并调用了那些函数&quot;&gt;&lt;a href=&quot;#Effective-C-条款05-了解C-默默编写并调用了那些函数&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款05:了解C++默默编写并调用了那些函数&quot;&gt;&lt;/a&gt;Effective C++ 条款05:了解C++默默编写并调用了那些函数&lt;/h1&gt;&lt;h2 id=&quot;1、众所周知C-的一个类中是有4个核心函数的&quot;&gt;&lt;a href=&quot;#1、众所周知C-的一个类中是有4个核心函数的&quot; class=&quot;headerlink&quot; title=&quot;1、众所周知C++的一个类中是有4个核心函数的&quot;&gt;&lt;/a&gt;1、众所周知C++的一个类中是有4个核心函数的&lt;/h2&gt;&lt;p&gt;构造函数，析构函数，拷贝构造函数，赋值构造函数。&lt;br&gt;而且一个空类，class内部什么都不做C++默认都会合成这写核心函数，当然是这些函数被调用的时候，他们才会被编译器创建出来。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Empty &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;下面的写法和上面效果一样：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Empty &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Empty()&amp;#123;···&amp;#125;                              &amp;#x2F;&amp;#x2F;default 构造函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Empty(const Empty&amp;amp; rhs) &amp;#123;···&amp;#125;    &amp;#x2F;&amp;#x2F;copy构造函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ~Empty() &amp;#123; ··· &amp;#125;                         &amp;#x2F;&amp;#x2F;析构函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Empty&amp;amp; operator&amp;#x3D;(const Empty&amp;amp; rhs) &amp;#123; ··· &amp;#125;&amp;#x2F;&amp;#x2F;copy assignment 操作符号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;如果是一个空类，下面的代码会造成上面的函数被编译器创建&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Empty e1;      &amp;#x2F;&amp;#x2F;default 构造函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#x2F;&amp;#x2F;析构函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Empty e2(e1);&amp;#x2F;&amp;#x2F;copy构造函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e2 &amp;#x3D; e1;        &amp;#x2F;&amp;#x2F;copy assignment 操作符号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-1-构造函数、析构函数是干嘛用的？&quot;&gt;&lt;a href=&quot;#1-1-构造函数、析构函数是干嘛用的？&quot; class=&quot;headerlink&quot; title=&quot;1.1 构造函数、析构函数是干嘛用的？&quot;&gt;&lt;/a&gt;1.1 构造函数、析构函数是干嘛用的？&lt;/h3&gt;&lt;p&gt;构造函数、析构函数主要是给编译器一个地方用来放置”藏身幕后”的代码，像是调用base classed  和 non-static 成员变量的构造函数和析构函数。&lt;br&gt;⚠️注意：编译器产出的析构函数是个 non-virtual 的，除非这个 class 的base class 自身声明有virtual 析构函数（这种情况下这个函数的虚属性主要来自bsae class）&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款04:确定对象被使用前已先被初始化</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2021-11-26T14:43:27.000Z</published>
    <updated>2021-11-26T14:44:27.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款04-确定对象被使用前已先被初始化"><a href="#Effective-C-条款04-确定对象被使用前已先被初始化" class="headerlink" title="Effective C++ 条款04:确定对象被使用前已先被初始化"></a>Effective C++ 条款04:确定对象被使用前已先被初始化</h1><h2 id="1、C-中将对象初始化中一些无法预料的情况"><a href="#1、C-中将对象初始化中一些无法预料的情况" class="headerlink" title="1、C++中将对象初始化中一些无法预料的情况"></a>1、C++中将对象初始化中一些无法预料的情况</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自某些语境下 x 保证被初始化（为0），但在其他语境中却不保证。</span><br><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">···</span><br><span class="line">Point p;</span><br></pre></td></tr></table></figure><p>p的成员变量有时候会被初始化为0，有时候不会。<br>读取未初始化的值会导致不明确的行为。</p><h2 id="2、一些初始化的规则"><a href="#2、一些初始化的规则" class="headerlink" title="2、一些初始化的规则"></a>2、一些初始化的规则</h2><p>通常如果你使用 C part of C++, 而且初始化可能招致运行期成本，那么就不保证发生初始化。<br>一旦进入 non-C parts of C++, 规则有些变化。这就很好地解释了为什么array 不保证其内容被初始化，而vector 却有此保证。</p><span id="more"></span><h3 id="2-1-内置类型初始化–-手动完成"><a href="#2-1-内置类型初始化–-手动完成" class="headerlink" title="2.1 内置类型初始化– 手动完成"></a>2.1 内置类型初始化– 手动完成</h3><p>由于我们不无法保证我们始终是处在一个状态。那么正确的做法是：永远在使用对象之前先将它初始化。<br>对于无任何成员的内置类型，必须手动完成此事。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 0;        &#x2F;&#x2F;对int 进行手工初始化</span><br><span class="line">const char *text &#x3D; &quot;A C-style string&quot;;      &#x2F;&#x2F;对指针进行手工初始化</span><br><span class="line">double d;</span><br><span class="line">std::cin &gt;&gt; d;    &#x2F;&#x2F;读取 input stream的方式完成初始化</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-内置类型以外的任何其他东西初始化–构造函数内部"><a href="#2-2-内置类型以外的任何其他东西初始化–构造函数内部" class="headerlink" title="2.2 内置类型以外的任何其他东西初始化–构造函数内部"></a>2.2 内置类型以外的任何其他东西初始化–构造函数内部</h3><p>对于内置类型以外的任何其他东西，初始化责任落在构造函数（constructors）身上。<br>规则很简单：确保每个够战术都将对象的每一个成员初始化。</p><h3 id="2-3-不要混淆-赋值（assignment）-和-初始化（initialization）"><a href="#2-3-不要混淆-赋值（assignment）-和-初始化（initialization）" class="headerlink" title="2.3  不要混淆 赋值（assignment） 和 初始化（initialization）"></a>2.3  不要混淆 赋值（assignment） 和 初始化（initialization）</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class PhoneNumber&#123;&#125;;</span><br><span class="line">class ABEntry &#123;</span><br><span class="line">public: </span><br><span class="line">  ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line">private:</span><br><span class="line">  std::string theName;</span><br><span class="line">  std::string theAddress;</span><br><span class="line">  std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">  int numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) &#123;</span><br><span class="line">  theName &#x3D; name;  &#x2F;&#x2F;  这些都是赋值，而不是初始化</span><br><span class="line">  theAddress &#x3D; address;</span><br><span class="line">  thePhones &#x3D; phones;</span><br><span class="line">  theTimesConsulted &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-构造函数的初始化最佳做法"><a href="#2-4-构造函数的初始化最佳做法" class="headerlink" title="2.4 构造函数的初始化最佳做法"></a>2.4 构造函数的初始化最佳做法</h3><p>这可以使得ABEntry对象带有你期望（你制定）的值，但不是最佳做法。<br>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。在ABEntry构造函数内， theName, theAddress,thePhone 都不是被初始化，而不是被赋值。<br>初始化发生的时间更早，发生于这些成员的default构造函数被自动调用之时。【比进入ABEntry构造函数本体的时间更早】。<br>numTimesConsulted除外，因为它属于内置类型，不保证一定在你所看到的那个赋值动作的时间点之前获得初值。</p><p>ABEntry构造函数的最佳写法是：成员初始化列表。member initialization list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是成员初始化列表，够着函数内部不用做任何动作</span><br><span class="line">ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt; &amp;phones)</span><br><span class="line">:theName(name),</span><br><span class="line">  theAddress(address),</span><br><span class="line">  thePhones(phones),</span><br><span class="line">  numTimesConsulted(0)&#123;&#125;</span><br></pre></td></tr></table></figure><p> 和赋值函数不同的是，<br>赋值函数会先调用 默认构造函数，为theName,theAddress,thePhoens设置初始值。<br>然后立刻再对他们赋予新值。default构造函数的一切作为都因此浪费了。<br>成员初始化列表避免了这个问题。<br>成员初始值列针对各个成员变量而设置的实参，被拿去作为各个成员变量的构造函数的实参。<br>本例中 theName以name为初始值进行copy 构造，theAddress  以address 为初始值进行copy 构造，thePhones 以phones 以 phones为初始值进行copy 构造。<br>ABEntry的无参数构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry()</span><br><span class="line">  :theName(), </span><br><span class="line">  theAddress(),</span><br><span class="line">  thePhones(),</span><br><span class="line">  numTimesConsulted(0)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>编译器会为用户自定义类型（user-defined types）的成员变量自动调用default构造函数–如果那些成员变量在”成员初值列”中没有被指定初值的还。<br>对于内置类型，若果成员初始列一楼了它，它就没有初始值。因此可能导致”不明确行为”。<br>所以，我们可以立下一个规则：<strong>总是在初始化列表中列出所有的成员变量</strong></p><h3 id="2-5-成员变量是-const-或-referneces的初始化"><a href="#2-5-成员变量是-const-或-referneces的初始化" class="headerlink" title="2.5 成员变量是 const 或 referneces的初始化"></a>2.5 成员变量是 const 或 referneces的初始化</h3><p><strong>如果成员变量是 const 或 referneces，它们一定需要初始值，不能被赋值。这里就需要成员初始化列表里初始化他们。</strong></p><p>如果classes拥有多个构造函数，每个构造函数有自己的成员初始值列。如果这种classes存在许多成员变量和/或base classes , 多份成员初值列的存在就会导致不受欢迎的重复（在初值列内）和无聊的工作。这种情况下可以合理地的在初值列中遗漏那些”赋值表现像初始化一样好的”成员变量，改用他们的赋值操作，并将那些复之操作移往某个函数（通常是private），供所有构造函数调用。<br>这种做法在”成员变量的初值是由文件或数据库读入”时特别有用。然而，比起经由赋值操作完成的”伪初始化”（pseudo-initialization）,通过成员初始列（member initialization list）完成”真正初始化”通常更加可取。<br>【和使用完整的初始化列表有矛盾？C++里经常是这样，可以这样，也可以那样，视情况而定】</p><p>C++有着十分固定的”成员初始化次序”。次序总是相同：base classes 更早于其derived classes被初始化， 而classes的成员变量总是以其声明次序被初始化。回头看 ABEntry,其 theName 成员永远最先被初始化，然后是 theAddress， 再来是 thePhones，最后是numTimesConsulted。即使他们在成员初值列中可以以不同的次序出现（C++允许这样）。为避免你或你的检阅这迷惑，并避免某些可能存在的晦涩错误，应当在成员初始列中条列各个成员时，最好总是以其声明次序为次序。<br>【例如，array初始化时，必须先初始化array的length 】</p><p>以上，内置类型初始化，而且构造函数运用”成员初值列”初始化base classes 和成员变量，那就剩唯一需要操心的<strong>不同编译但愿内定义的non-local static 对象</strong>的初始化次序。</p><h3 id="2-6-static对象的初始化"><a href="#2-6-static对象的初始化" class="headerlink" title="2.6 static对象的初始化"></a>2.6 static对象的初始化</h3><p>static对象，其生命周期从被构造出来直到程序结束为止，因此stack和heap-based对象都被排除。<br>这种对象包括global对象、定义与namespace作用域内的对象、在classes内、在函数内、以及在file 作用域内被声明为static 的对象。<br>函数内的static对象称为 local static 对象(因为他们呢对函数而言是 local)， 其他static 对象 称为 non-local static对象。程序结束时static对象会自动被销毁，也就是它们的析构函数会在main()结束时被自动调用。</p><p>所谓编译单元（translation unit） 是指产出单一目标文件（single object file） 的那些源码。基本上是单一源文件假设昂其所包含的头文件（#include files）.</p><p>会出问题的情况：涉及两个源码文件，每一个内至少一个 non-local static 对象（也就是说该对象是global 或 位于 namespace  作用域内， 抑或在class 内或 file 作用域内被声明为 static）。真正的问题是： 如果某编译单元内的某个 non-local static 对象的初始化动作使用了 另一个编译单元的某个 non-local static 对象，它所用到的 这个对象可能尚未被初始化，因为C++ 对”定义于不同编译单元内的 non-local static对象”的初始化次序并无明确定义。</p><p>例如：你有一个FileSystem class,它让互联网上的文件看起来好像位于本机（local）。由于这个class 使世界看起来像个单一文件系统，你可能会产出一个特殊对象，位于global 或 namespace 作用域内，象征单一文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem &#123;          &#x2F;&#x2F;来自你的程序库</span><br><span class="line">public:</span><br><span class="line">  ···</span><br><span class="line">  std::size_t numDisks() const;    &#x2F;&#x2F;众多成员函数之一</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">extern FileSystem tfs;      &#x2F;&#x2F;预备给客户使用的对象；</span><br></pre></td></tr></table></figure><p>FileSystem对象绝对不是一个稀松平常无关痛痒的（trival)对象，因此 你的客户如果在theFileSystem 对象构造完成前就使用它，会遭到灭顶之灾。</p><p>现在假设某些客户建立了一个class用以处理文件系统内的目录（directories）。很自然他们的class会用上theFileSystem 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Directory &#123;</span><br><span class="line">public:</span><br><span class="line">  Directory(params);</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory(params) &#123;</span><br><span class="line">  ···</span><br><span class="line">  std:size_t disks &#x3D; tfs.numDisks();  &#x2F;&#x2F;使用 tfs对象</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步假设，这些客户决定创建一个 Directory 对象，用来放置临时文件：<br>Directory tempDir(params);    //为临时文件而做出的目录</p><p>现在，初始化次序的重要性显示出来了：除非tfs 在 tempDir 之前先被初始化，否则tempDir 的构造函数会用到尚未初始化的 tfs。但tfs 和 tempDir 是不同的人在不同时间于不同的源码文件建立起来的，它们是定于不同编译单元内的 non-local static对象。如何能够确定 tfs 会在 tempDir 之前被初始化？<br><strong>希特，你无法确定</strong><br><strong>C++对于”定义于不同的编译但愿内的non-local static 对象”的初始化相对次序并无明确定义</strong><br>这是因为：决定他们的初始化次序相当困难，非常困难，根本无解。最常见的形式，也就是多个编译单元内的 non-local static 对象经由”模版隐式具现化，implicit template instantiations”形成（而后者可能也是经由”模板隐式具现化”形成），不但不可能决定正确的初始化次序，甚至往往不值得寻找”可决定正确次序”的特殊情况。</p><p>怎么解决这个 non-local static对象在不同的对象嵌套是初始化顺序无法确定呢？？<br>方法是：<strong>将每个non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为static）</strong><br><strong>这些函数返回一个 reference 指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。</strong></p><p>换句话说，non-local static 对象被 local static 对象替换了。没错这也是设计模式里，Singleton单例模式的一个常见实现手法。</p><p>这个手法得以成功的基础在于：C++保证，函数内的local static 对象会在 “该函数被调用期间””首次遇上该对象之定义式”时被初始化。所以如果你以”函数调用”（返回一个reference 指向local static 对象）替换”直接访问 non-local static 对象”，你就获得了保证，保证你所获得的那个reference将指向一个历经初始化的对象。更棒的是，如果你从未调用non-local static 对象的”仿真函数”，就绝不会引发构造和析构成本；真正的non-local static 对象可没有这等优势。</p><p>这中技术施行与tfs 和 tempDir上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem&#123; ··· &#125;；&#x2F;&#x2F;同前</span><br><span class="line">&#x2F;&#x2F;这个函数用来替换提tfs 对象；它在FileSystem calss 中可能是个static。</span><br><span class="line">FileSystem&amp; tfs() &#123;    </span><br><span class="line">  static FileSystem fs;  &#x2F;&#x2F;定义并初始化一个local static对象， 返回一个 reference 指向上述对象。</span><br><span class="line">  return fs;</span><br><span class="line">&#125;</span><br><span class="line">class Directory&#123; ··· &#125;;  &#x2F;&#x2F;同前</span><br><span class="line">Directory::Directory( params ) &#123;&#x2F;&#x2F;  同前，但是原本的 reference to tfs 现在改为tfs()</span><br><span class="line">  ···</span><br><span class="line">  std::size_t disks &#x3D; tfs().numDisks();</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;这个函数用来替换tempDir 对象；它在Directory class 中可能是个 static。定义并初始化local static 对象，返回一个 reference 指向上述对象</span><br><span class="line">Directory&amp; tempDir() &#123;</span><br><span class="line">  static Directory td;</span><br><span class="line">  return td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后的程序，这个系统程序的客户完全像以前一样的使用它，唯一不同的是他们现在使用 tfs() 和 tempDir() 而不再是 tfs 和 tempDir。<br>也就是说他们使用函数返回的”指向static 对象”的references, 而不再使用static对象自身。</p><p>这种结构下的 reference-returning 函数往往十分单纯： 第一行定义并初始化一个 local static对象， 第二行返回它。<br>这样的单纯性使它们成为绝佳的inlining 候选人，尤其是它们被频繁调用的话。<br>但是这些函数中<strong>内含 static 对象</strong>，不论它是local或者non-local，在多线程环境下”等待某事发生”都会有麻烦。处理这个麻烦的一种做法是： 在程序的单线程启动阶段（single-threaded startup portion）手工调用所有 reference-returning函数，这可能消除与初始化有关的”竞速形势（race conditions）”。</p><p>当然，reference-returning函数防止”初始化次序问题”，前提是其中有着一个对对象而言合理的初始化次序。如果你有一个系统，其中对象A必须在对象B之前先初始化，但A的初始化能否成功却又受制于B是否已初始化，这时候你就有麻烦了。这样鸡生蛋，蛋生鸡的问题你搞出来你是自作自受。</p><p>综上，为避免在对象出售话之前过早地使用它们，你需要做三件事。</p><ul><li>第一：手工初始化内置型 non-member 对像</li><li>第二：使用成员初值列（member initialization lists）处理所有成员变量。</li><li>最后：在”初始化次序不确定性”的情况下，加强设计。利用calss内函数 内部的 local static 替换对象的 non-local static对象。使用饮用而不是直接使用对象。还要注意 多线程的时候，提前手动调用 这个内部函数。保证线程安全。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款04-确定对象被使用前已先被初始化&quot;&gt;&lt;a href=&quot;#Effective-C-条款04-确定对象被使用前已先被初始化&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款04:确定对象被使用前已先被初始化&quot;&gt;&lt;/a&gt;Effective C++ 条款04:确定对象被使用前已先被初始化&lt;/h1&gt;&lt;h2 id=&quot;1、C-中将对象初始化中一些无法预料的情况&quot;&gt;&lt;a href=&quot;#1、C-中将对象初始化中一些无法预料的情况&quot; class=&quot;headerlink&quot; title=&quot;1、C++中将对象初始化中一些无法预料的情况&quot;&gt;&lt;/a&gt;1、C++中将对象初始化中一些无法预料的情况&lt;/h2&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;自某些语境下 x 保证被初始化（为0），但在其他语境中却不保证。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Point &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int x, y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Point p;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;p的成员变量有时候会被初始化为0，有时候不会。&lt;br&gt;读取未初始化的值会导致不明确的行为。&lt;/p&gt;
&lt;h2 id=&quot;2、一些初始化的规则&quot;&gt;&lt;a href=&quot;#2、一些初始化的规则&quot; class=&quot;headerlink&quot; title=&quot;2、一些初始化的规则&quot;&gt;&lt;/a&gt;2、一些初始化的规则&lt;/h2&gt;&lt;p&gt;通常如果你使用 C part of C++, 而且初始化可能招致运行期成本，那么就不保证发生初始化。&lt;br&gt;一旦进入 non-C parts of C++, 规则有些变化。这就很好地解释了为什么array 不保证其内容被初始化，而vector 却有此保证。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款03:尽可能使用const</title>
    <link href="http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/"/>
    <id>http://jarvissky.com/2021/11/26/Effective-C-%E6%9D%A1%E6%AC%BE03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</id>
    <published>2021-11-26T14:41:28.000Z</published>
    <updated>2021-11-26T14:43:59.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款03-尽可能使用const"><a href="#Effective-C-条款03-尽可能使用const" class="headerlink" title="Effective C++ 条款03:尽可能使用const"></a>Effective C++ 条款03:尽可能使用const</h1><h2 id="1、const-允许你指定一个语义约束，指定一个不该被改动的对象"><a href="#1、const-允许你指定一个语义约束，指定一个不该被改动的对象" class="headerlink" title="1、const 允许你指定一个语义约束，指定一个不该被改动的对象"></a>1、const 允许你指定一个语义约束，指定一个不该被改动的对象</h2><p>就像一个魔咒，你给一个姑娘下一个魔咒，规定她只能爱你一个人（有点邪恶😈。。。）<br>或者说，const 修饰的对象都是单纯的姑娘，一旦爱上你，只爱你一个人，永远变心。</p><h2 id="2、const-可以用在哪里"><a href="#2、const-可以用在哪里" class="headerlink" title="2、const 可以用在哪里"></a>2、const 可以用在哪里</h2><p>可以在class外部修饰 global或 namespace作用域中的常量。<br>可以修饰文件，函数，或区块作用域（block scope） 中被声明为static的对象。你也可以用它修饰classes 内部的statis和no-static成员变量。<br>面对指针，你也可以指出指针自身、指针所指物，或者两者都是cosnt.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char greeting[] &#x3D; &quot;Hello&quot;; </span><br><span class="line">char *p &#x3D; greeting;           &#x2F;&#x2F;non-const pointer, non-const data</span><br><span class="line">const char *p &#x3D; greeting;  &#x2F;&#x2F;non-const pointer, const data</span><br><span class="line">char *const p &#x3D; greeting;  &#x2F;&#x2F;const pointer, non-const data</span><br><span class="line">const char* const p &#x3D; greeting;  &#x2F;&#x2F;const pointer, const data</span><br></pre></td></tr></table></figure><p>const 语法虽然变化多端，但并不莫测高深。<br><strong>如果关键字const 出现在*左边，表示被指物是常量</strong><br><strong>如果关键字const 出现在*右边，表示指针自身是常量</strong><br><strong>如果关键字const 出现在*左右两边，表示被指物和指针都是常量</strong><br>如果被指物是常量，有些程序员会将关键字const 写在类型之前，有些人会把它写在类型之后、星号之前。两种写法的意义相同，所以下列两个函数接受的函数类型是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void f1(const Widget *pw);  &#x2F;&#x2F;f1获得一个指针，指向一个常量的（不变的）widget对象</span><br><span class="line">void f2(Widget cosnt *pw);  &#x2F;&#x2F;f2 也是</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="3、STL迭代器-const"><a href="#3、STL迭代器-const" class="headerlink" title="3、STL迭代器 const"></a>3、STL迭代器 const</h2><p>STL迭代器系以指针为根据塑模出来，所以迭代器的作用就像个T<em>指针。声明迭代器const 就像声明指针为const 一样（即声明一个 T</em> cosnt 指针），表示这个迭代器不得指向不同的东西，但它所指的东西的值是可以改动的。如果你希望迭代器所指的东西不可被改动（即希望STL模拟一个const T*指针），你需要的是const_iterator:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">···</span><br><span class="line">const std::vector&lt;int&gt;::iterator iter &#x3D; vec.begin(); &#x2F;&#x2F;iter 的作用像个 T* const</span><br><span class="line">*iter &#x3D; 10;  &#x2F;&#x2F;  没问题，改变 iter所指物</span><br><span class="line">++iter;      &#x2F;&#x2F;错误！iter 是const</span><br><span class="line">std::vector&lt;int&gt; ::const_iterator cIter &#x3D; vec.begin();&#x2F;&#x2F;cIter的作用像个const T*</span><br><span class="line">*cIter &#x3D; 10;  &#x2F;&#x2F;  错误！ *cIter 是const</span><br><span class="line">++cIter;      &#x2F;&#x2F;  没问题，改变cIter</span><br></pre></td></tr></table></figure><p>const最具威力的用法是面对函数声明时的应用。在一个函数声明式内，const可以和函数返回值、各参数、函数自身（如果是成员函数）产生关联。</p><h2 id="4、const-返回值"><a href="#4、const-返回值" class="headerlink" title="4、const 返回值"></a>4、const 返回值</h2><p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。<br>例如 operator * 声明式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Rational&#123;   ···   &#125;;</span><br><span class="line">const Rational operator* (const Rational&amp; lhs, const Rational &amp;rhs);</span><br></pre></td></tr></table></figure><p>不要诧异，为什么函数返回的是一个cosnt对象。因为如果不这样做的话，客户可能这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">···</span><br><span class="line">(a*b) &#x3D; c;  &#x2F;&#x2F;在a * b的成果上调用 operator&#x3D;</span><br></pre></td></tr></table></figure><p>对两个数的乘积做赋值，一般是在输入错误的时候才这样做。例如 ‘==’ 输入成 ‘=’。<br>如果把返回值标注为const 就可以在编辑阶段发现可能潜在的逻辑错误。</p><h2 id="5、const-参数"><a href="#5、const-参数" class="headerlink" title="5、const 参数"></a>5、const 参数</h2><p>除非你有需要改动的参数或local对象，否则请将它们声明为const。</p><h2 id="6、const-成员函数"><a href="#6、const-成员函数" class="headerlink" title="6、const 成员函数"></a>6、const 成员函数</h2><p>将cosnt实施于成员函数的目的，是为了确保该成员函数可作用于const对象。<br>1、他们使class接口比较容易理解。明确了哪个函数可以改动对象内容，而哪个函数不行。<br>2、他们使”操作const对象”成为可能。C++提高程序效率的一个根本办法是以pass by reference-to-const方式传递对象。此技术可行的前提是，我们有const成员函数可用来取得（并经修饰而成）的const对象。</p><p>一个事实：两个成员函数如果只是常量性（constness） 不同，可以被重载。这是C++一总要特性<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line">  &#x2F;&#x2F;operator[] for const 对象</span><br><span class="line">  const char&amp; operator[](std::size_t position) const &#123;</span><br><span class="line">    return text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;operator[] for non-const 对象</span><br><span class="line">   char&amp; operator[](std::size_t position) &#123;</span><br><span class="line">    return text[position];</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  std::string text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TextBlock 的 operator[]s 可以这么使用：</span><br><span class="line">TextBlock tb&#123;&quot;Hello&quot;&#125;;</span><br><span class="line">std::const &lt;&lt; tb[0];    &#x2F;&#x2F;调用 non-const TextBlock::operator[]</span><br><span class="line">const TextBlock ctb(&quot;World&quot;);</span><br><span class="line">std::const &lt;&lt; ctb[0];    &#x2F;&#x2F;调用const TextBlock::operator[]</span><br></pre></td></tr></table></figure><p>附带一提，真实程序中 const 对象大多数用于passed by pointer-to-const 或 passed by reference-to-const的传递结果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void print(const TextBlock&amp; ctb) &#123;</span><br><span class="line">  std::cout &lt;&lt; ctb[0];    &#x2F;&#x2F;调用 const TextBlock::operator[]</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要重载operator[]并对不同的版本给予不同的返回类型，就可以令const和 no-const TextBlocks 获得不同的处理：<br>std::cout &lt;&lt; tb[0];    //没问题–读一个non-const TextBlock<br>tb[0] = ‘x’;              //没问题–写一个non-const TextBlock<br>std::cout &lt;&lt; ctb[0];  //没问题–读一个const TextBlock<br>ctb[0] = ‘x’;            //错误–写一个const TextBlock</p><p>上述例子，operator[] 调用动作本身没有问题。错误起因于企图对于一个”由const 版的operator[]返回”的const char&amp; 实施赋值。</p><p>也请注意，non-const operator[] 返回的类型是一个 reference to char,而不是char.<br>如果 operator[]只是返回一个char，下面这样的语句是无法通过编译的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tb[0] &#x3D; &#39;x&#39;;</span><br></pre></td></tr></table></figure><p>这是因为，如果函数的返回类型是个内置类型，那么改动函数返回值从来就不合法。纵使合法，C++以by value返回对象这一事实意味着被改动的其实是 tb.text[0]的一个副本。而不是tb.text[0]自身。</p><p>成员函数如果是const意味着什么？<br>这里有两个概念：bitwise constness（又称 physical constness） 和 logical constness.<br>bitwise const 阵营的人认为，成员函数之后在不更改对象的任何成员变量（static除外）时才可以说是const。也就是说它不更改对象内的任何一个bit。这种论点的好处是容易侦测反点：编译器只需要寻找成员变量的赋值动作即可。bitwise constness正是C++对常量性（constness）的定义，因此const 成员函数不可以更改对象内任何non-static 成员变量。</p><p>不幸的是许多成员函数虽然不具备const性质却能通过bitwise 测试。更具体地说，一个更改了”指针所指物”的成员函数虽然不能算是const,但如果只具有指针（而非其所指物）隶属于对象，那么称此函数为bitwise const 不会引发编译器异议。这导致反直观结果。假设我们有一个TextBlock-lick class，它将数据存储为char* 而不是string,因为它需要和一个不认识string对象的 C API沟通：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line">  &#x2F;&#x2F;bitwise const 声明，但其实不适当</span><br><span class="line">  char&amp; operator[](std::size_t position) const &#123;</span><br><span class="line">    return pText[position];</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  char* pText;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个class不适当的将其operator[] 声明为const成员函数，而该函数却返回一个 reference 指向对象内部值（条款28有深刻讨论）。假设暂时不管这个事实，请注意，operator[]实现代码并不更改pText.于是编译器很开心滴为operator[]产出目标代码。他是bitwise const，所有编译器都这么认定。但是看看它允许发生什么事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const CTextBlock cctb(&quot;Hello&quot;);  &#x2F;&#x2F;  声明一个常量对象</span><br><span class="line">char* pc &#x3D; &amp;cctb[0];                  &#x2F;&#x2F;调用 const operator[] 取得一个指针，指向cctb 数据</span><br><span class="line">*pc &#x3D; &quot;J&quot;;                                &#x2F;&#x2F;cctb 现在有了&quot;Jello&quot;这样的内容</span><br></pre></td></tr></table></figure><p>这里当然不该有任何错误：你创建一个常量对象并设以某值，而且只对它调用了const成员函数。但你终究还是改变了它的值。</p><p>这种情况导出所谓的 logical constness。这一派拥护者主张，一个const成员函数可以修改它所处理的对象内的某些bits,但只有在客户端侦测不出的情况下才得如此。例如你的CTextBlock class 有可能高速缓存（cache）文本区块的长度以便应付询问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlcok &#123;</span><br><span class="line">public:</span><br><span class="line">  std::size_t length() const;</span><br><span class="line">private:</span><br><span class="line">  char *pText;</span><br><span class="line">  std::size_t textLength;  &#x2F;&#x2F;最近一次计算的文本区块长度</span><br><span class="line">  bool lengthIsValid;      &#x2F;&#x2F; 目前长度是否有效</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::siez_t CTextBlock::length() const &#123;</span><br><span class="line">  if(!lengthIsValid) &#123;</span><br><span class="line">    textLength &#x3D; std::strlen(pText);</span><br><span class="line">    textIsValid &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  return textLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>length 的实现当然不是bitwise const ,因为 textLength 和 lengthIsValid都可能被修改。这两笔数据被修改对  const CTextBlock对象而言虽然可接受，但编译器不统一。他们坚持bitwise constness.怎么办？<br>解决办法很简单：利用C++的一个与cosnt相关的摆动场：mutable(可变的)。<br>mutable释放掉non-static成员变量的bitwise constness约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlck &#123;</span><br><span class="line">public:</span><br><span class="line"> ···</span><br><span class="line">  static::size_t length() cosnt;</span><br><span class="line">private:</span><br><span class="line">char* pText;</span><br><span class="line">mutable std::size_t textLength;    &#x2F;&#x2F;这些成员变量可能总是会被更改，即使在const成员函数内</span><br><span class="line">mutable bool lengthIsValid;          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::size_t CTextBlock::length() const &#123;</span><br><span class="line">  if(!lengthIsValid) &#123;</span><br><span class="line">    textLength &#x3D; std::strlen(pText);  &#x2F;&#x2F;  现在，可以这样，也可以这样</span><br><span class="line">    lengthIsValid &#x3D; true;  </span><br><span class="line">  &#125;</span><br><span class="line">  return textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、为避免代码重复，利用const-函数调用-non-const-函数，以达到复用的效果"><a href="#7、为避免代码重复，利用const-函数调用-non-const-函数，以达到复用的效果" class="headerlink" title="7、为避免代码重复，利用const 函数调用 non-const 函数，以达到复用的效果"></a>7、为避免代码重复，利用const 函数调用 non-const 函数，以达到复用的效果</h2><p>mutable可以解决一些 const内部无法改变成员变量的问题。但是并非能解决所有难题。<br>假如TextBlock 和 CTextBlock 内的operato[] 不只是返回一个reference指向某字符，也执行边界检查（bounds checking）、日志访问信息（logged access info.）、甚至可能进行完整性检验。把所有这些同时放进const 和 non-const operator[]中，这样虽然不被提倡，但是确实是存在的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public: </span><br><span class="line">···</span><br><span class="line">  const char&amp; operator[](std::size_t position) const &#123;</span><br><span class="line">    ···&#x2F;&#x2F;边界检查  (bounds checking)</span><br><span class="line">    ···&#x2F;&#x2F;日志访问数据  (log access data)</span><br><span class="line">    ···&#x2F;&#x2F;数据完整行验证 (verify data integrity)</span><br><span class="line">    return text[position];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  char&amp; operator[](std::size_t position) const &#123;</span><br><span class="line">    ···&#x2F;&#x2F;边界检查  (bounds checking)</span><br><span class="line">    ···&#x2F;&#x2F;日志访问数据  (log access data)</span><br><span class="line">    ···&#x2F;&#x2F;数据完整行验证 (verify data integrity)</span><br><span class="line">    return text[position];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样代码就很棒，哦不，就太冗余了。<br>我们想做到 实现operator[] 一次，并能使用它两次。也就是必须是其中一个调用另一个。<br>这里我们就使用到将常量性移除（casting away constness）<br>就一般守则而言，转型（casting）是一个糟糕的想法，【条款27专门讲强制转换】<br>但是这里为了减少代码冗余，我们就利用casting了。</p><p>我们应该让const operator[] 完全做掉 non-const版本该做的一切，唯一不同的是其返回类型多了一个const 资格修饰。<br>这种情况下，如果将返回值的const 转除是安全的，因为不论谁调用 non-const operator[] 都一定首先有一个 non-const 对象，否则就不能够调用non-const 函数。所以 令 non-const operator[]  调用其const 兄弟是一个避免代码重复的安全做法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line">  const char&amp; operator[] (std::size_t position) const &#123;</span><br><span class="line">    ···</span><br><span class="line">    ···</span><br><span class="line">    ···</span><br><span class="line">    return text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;将op[]返回值的const转除 为*this 加上 const 调用 const op[]</span><br><span class="line">  char&amp; operator[](std::size_t position) &#123;</span><br><span class="line">    return const_cast&lt;char &amp;&gt;(</span><br><span class="line">      static_cast&lt;const TextBlock&gt;(*this)[position]</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这份代码有两个转型动作，而不是一个。<br>我们打算让 non-const operator[]  调用其 const兄弟，但 non-const operator[] 内部若只是单纯调用 operato[],会递归调用自己。<br>为了避免无穷递归，我们必须明确指出调用的是 const operator[], 但C++缺乏直接的语法可以那么做。 因此这里将 *this 从其原始类型 TextBlock&amp; 转型为 cosnt TextBlock&amp;。 是的，我们使用转型操作为他加上const。 所以这里共两次转型：<br>第一次用来为 *this 添加 const( 这使得调用 operator[] 时得以调用 const 版本)，<br>第二次则是从 const operator[] 的返回值中移除 const.</p><p>添加const 的那次转型强迫进行了一次安全转型（将 non-const 对象转为 const 对象），所以我们使用 static_cosnt。移除const的那个动作只可以籍由const_cast 完成，没有其他选择（就技术而言其实是有的：一个 C-style转型也行得通）</p><p>我们不应该用 const 版本调用 non-const版本。这违反了const的设计本意， const 成员函数承诺绝不改变对象的逻辑状态。non-const函数没有这种约束。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款03-尽可能使用const&quot;&gt;&lt;a href=&quot;#Effective-C-条款03-尽可能使用const&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款03:尽可能使用const&quot;&gt;&lt;/a&gt;Effective C++ 条款03:尽可能使用const&lt;/h1&gt;&lt;h2 id=&quot;1、const-允许你指定一个语义约束，指定一个不该被改动的对象&quot;&gt;&lt;a href=&quot;#1、const-允许你指定一个语义约束，指定一个不该被改动的对象&quot; class=&quot;headerlink&quot; title=&quot;1、const 允许你指定一个语义约束，指定一个不该被改动的对象&quot;&gt;&lt;/a&gt;1、const 允许你指定一个语义约束，指定一个不该被改动的对象&lt;/h2&gt;&lt;p&gt;就像一个魔咒，你给一个姑娘下一个魔咒，规定她只能爱你一个人（有点邪恶😈。。。）&lt;br&gt;或者说，const 修饰的对象都是单纯的姑娘，一旦爱上你，只爱你一个人，永远变心。&lt;/p&gt;
&lt;h2 id=&quot;2、const-可以用在哪里&quot;&gt;&lt;a href=&quot;#2、const-可以用在哪里&quot; class=&quot;headerlink&quot; title=&quot;2、const 可以用在哪里&quot;&gt;&lt;/a&gt;2、const 可以用在哪里&lt;/h2&gt;&lt;p&gt;可以在class外部修饰 global或 namespace作用域中的常量。&lt;br&gt;可以修饰文件，函数，或区块作用域（block scope） 中被声明为static的对象。你也可以用它修饰classes 内部的statis和no-static成员变量。&lt;br&gt;面对指针，你也可以指出指针自身、指针所指物，或者两者都是cosnt.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;char greeting[] &amp;#x3D; &amp;quot;Hello&amp;quot;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *p &amp;#x3D; greeting;           &amp;#x2F;&amp;#x2F;non-const pointer, non-const data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char *p &amp;#x3D; greeting;  &amp;#x2F;&amp;#x2F;non-const pointer, const data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *const p &amp;#x3D; greeting;  &amp;#x2F;&amp;#x2F;const pointer, non-const data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char* const p &amp;#x3D; greeting;  &amp;#x2F;&amp;#x2F;const pointer, const data&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;const 语法虽然变化多端，但并不莫测高深。&lt;br&gt;&lt;strong&gt;如果关键字const 出现在*左边，表示被指物是常量&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果关键字const 出现在*右边，表示指针自身是常量&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果关键字const 出现在*左右两边，表示被指物和指针都是常量&lt;/strong&gt;&lt;br&gt;如果被指物是常量，有些程序员会将关键字const 写在类型之前，有些人会把它写在类型之后、星号之前。两种写法的意义相同，所以下列两个函数接受的函数类型是一样的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void f1(const Widget *pw);  &amp;#x2F;&amp;#x2F;f1获得一个指针，指向一个常量的（不变的）widget对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void f2(Widget cosnt *pw);  &amp;#x2F;&amp;#x2F;f2 也是&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款02: 尽量以const, enum, inline 替换#define</title>
    <link href="http://jarvissky.com/2021/11/13/Effective-C-%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline-%E6%9B%BF%E6%8D%A2-define/"/>
    <id>http://jarvissky.com/2021/11/13/Effective-C-%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline-%E6%9B%BF%E6%8D%A2-define/</id>
    <published>2021-11-13T08:20:10.000Z</published>
    <updated>2021-11-26T14:42:31.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-条款02-尽量以const-enum-inline-替换-define"><a href="#Effective-C-条款02-尽量以const-enum-inline-替换-define" class="headerlink" title="Effective C++ 条款02: 尽量以const, enum, inline 替换#define"></a>Effective C++ 条款02: 尽量以const, enum, inline 替换#define</h1><h2 id="1、-define-宏定义的记号名称从未被编译器看见"><a href="#1、-define-宏定义的记号名称从未被编译器看见" class="headerlink" title="1、#define  宏定义的记号名称从未被编译器看见"></a>1、#define  宏定义的记号名称从未被编译器看见</h2><p>【注意，作者这里没有称之为变量】<br>#define ASPECT_RATIO 1.653<br>ASPECT_RATIO这个记号也许从来就没有被编译器看见；也许在编译器开始处理源码之前他就被预处理器移走了。于是，ASPECT_RATIO根本没有进入符号表（symbol table）内。如果出现编译错误，可能编译器爆出的是1.653错了，。。。可能你压根想不到是自己定义的ASPECT_RATIO所指的意义。<br>预处理时会把源代码里的ASPECT_RATIO替换为 1.653，没有类型检查</p><span id="more"></span><h2 id="2、解决之道：用一个常量替换上述的宏（-define）"><a href="#2、解决之道：用一个常量替换上述的宏（-define）" class="headerlink" title="2、解决之道：用一个常量替换上述的宏（#define）"></a>2、解决之道：用一个常量替换上述的宏（#define）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double AspectRatio &#x3D; 1.653;  &#x2F;&#x2F;大写常用与宏，因此这里用变量名的定义规则</span><br></pre></td></tr></table></figure><p>作为一个语言常量，AspectRatio肯定会被编译器看到，当就会进入记号表内。此外对浮点常量（floating point constant,）而言，使用常量可能比使用#define导致较小的码，因为预处理器”盲目地将宏名称ASPECT_RATIO替换为1.653”可能导致目标码（object code）出现多分1.653，若改为常量AspectRatio绝不会出现相同的情况。</p><h3 id="2-1-用常量指针（constant-pointers）"><a href="#2-1-用常量指针（constant-pointers）" class="headerlink" title="2.1 用常量指针（constant pointers）"></a>2.1 用常量指针（constant pointers）</h3><p>由于常量定义式通常被放在头文件内（以便被不同的源码引入），因此有必要将指针（而不是指针所指之物）声明为const。例如若要在头文件内定义一个常量（不变的）char*-based字符串，必须写两次const:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* const authorName &#x3D; &quot;Scott Meyers&quot;;</span><br></pre></td></tr></table></figure><p>C++定义常量时，使用string对象更合时宜</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const std::string authorName(&quot;Scott Meyers&quot;); </span><br></pre></td></tr></table></figure><h3 id="2-2-class-专属常量"><a href="#2-2-class-专属常量" class="headerlink" title="2.2 class 专属常量"></a>2.2 class 专属常量</h3><p>为了将常量的作用域限制在class内，必须让它成为class 的一个成员（member）;而确保此常量至多只有一份实体，必须让它成为一个static成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">  static const int NumTurns &#x3D; 5;  &#x2F;&#x2F;  声明类内常量</span><br><span class="line">  int scores[NumTurns];  &#x2F;&#x2F;使用该常量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，这里所看到的是 NumTurns的声明式。通常C++要求你对你所使用的任何东西提供一个定义式，但如果它是个class专属常量又是static 且为正数类型（integral type, 例如 ints, cahrs, bools）,则需要特殊处理。只要不取他们的地址，你可以声明并使用它们，而无需提供定义式。但如果你取某个class专属常量的地址，或纵使你不取其地址而你的编译器却坚持（不正确地）坚持要看到一个定义式，你就必须另外提供定义式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int GamePlayer::NumTurns;  &#x2F;&#x2F;NumTurns的定义，下面告诉你为什么没有给予数值</span><br></pre></td></tr></table></figure><p>请把这个式子放进一个实现文件而非非头文件。由于class 常量已在声明时获得初值（例如先前声明NumTurns 时为它设初值5），因此定义时不可以再设置初值。<br><strong>不可以在class内使用宏定义</strong><br>如果编译器不支持上诉语法，可以将初值放在定义式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ConstEstimate &#123;</span><br><span class="line">private:</span><br><span class="line">  static const double FudgeFactor;  &#x2F;&#x2F; static class 常量声明，位于头文件内</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;static class 常量声明位于头文件内</span><br><span class="line">const double ConstEstimate::FudgeFactor &#x3D; 1.35;</span><br></pre></td></tr></table></figure><p>这几乎是你在任何时候唯一需要做的事情。唯一例外是当你子class编译期间需要一个class常量值，例如在上述的GamePlayer::scores的数组声明式中（是的，编译器坚持必须在编译期间知道数组的大小）。这时候万一你的编译器（错误地）不允许”static 整数型class常量”完成”in class初值设定”，可改用所谓的”the enum hack “补偿做法。其理论基础是：”一个属于枚举类型（enumerated type）的数值可权充ints被使用”，于是 GamePlayer可定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">  enum &#123; NumTurns &#x3D; 5&#125;;&#x2F;&#x2F;&quot;the enum hack&quot;令NumTurns 成为5的一个记号名称。这就没问题了</span><br><span class="line">  int scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于”the enum hack”<br>1、enum hack 的行为某方面说比较像#define而不像cosnt, 有时候这正是你想要的，例如 取一个const的地址是合法的，但是去一个enum的地址就是不合法，而取一个#define的地址通常也不合法。<br>如果你想不让别人获得一个pointer或reference指向你的某个整数常量，enum 可以帮助你实现这个约束。条款18”通过撰写码时决定实施设计上的约束条件谈的更多”。<br>2、虽然优秀的编译器不会为”整数型const对象”设定另外的存储空间（除非你创建一个pointer 或 reference指向该对象）不够优秀的编译器却可能如此，而这可能是你不想要的。Enums 和 #define一样绝不会导致非必要的内存分配。<br>3、enum hack 纯粹是为了实用主义。许多代码用了它。它是模板元编程（template metaprogramming）的基础技术。</p><h2 id="3、预处理器的错误用法"><a href="#3、预处理器的错误用法" class="headerlink" title="3、预处理器的错误用法"></a>3、预处理器的错误用法</h2><p>宏函数：看起来像函数，但不会招致函数调用（function call）带来的额外开销。下面这个宏夹带着宏实参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以a和b 的较大值调用f</span><br><span class="line">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br></pre></td></tr></table></figure><p>那么多括号，看起来都烦啊。但是宏中的实参必须用括号扩起来，否则别人调用可能会有麻烦。<br>就算加了小括号，还有可能出现不可思议的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a  &#x3D; 5, b &#x3D; 0;</span><br><span class="line">CALL_WITH_MAX(++a, b);&#x2F;&#x2F; a 被累加两次</span><br><span class="line">CALL_WITH_MAX(++a, b + 10);  a被累加一次</span><br></pre></td></tr></table></figure><p>在这里，调用f之前，a的递增次数竟然取决于”它被拿来和谁比较”！</p><p>幸运的是，我们有办法解决这个问题。你可以获得宏带来的效率以及一般函数所有可能预料行为和类型安全性（type safety）—-只要写出template inline 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;由于我们不知道T是什么，所以采用pass by reference-to-const. 条款20</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T&amp; a, const T&amp; b) &#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个tempalte产出一整群函数，每个函数都可以接受两个同类型对象，并以其中较大者调用f。这里不需要在函数本体中为参数加上括号，也不需要操心参数被核算（求值）多次……等等。此外 callWithMax是一个真正的函数，它遵守作用域（scope）和访问规则。<br>你绝对可以写一个”class 内的private inline函数”。一般而言宏无法完成此事。</p><p>有了 const, enum ,inline。我们对预处理器的需求就降低了。<br>但并未完全消除，#include  仍然是必需品，而 #ifdef/#ifndef也继续扮演控制编译器的重要角色。目前还不到预处理器全面隐退的时候。</p><ul><li>对于单纯的常量，最好以cosnt对象或enum 替换#define</li><li>对于形似函数的宏macros, 最好改用 inline 函数替换 #define</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Effective-C-条款02-尽量以const-enum-inline-替换-define&quot;&gt;&lt;a href=&quot;#Effective-C-条款02-尽量以const-enum-inline-替换-define&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ 条款02: 尽量以const, enum, inline 替换#define&quot;&gt;&lt;/a&gt;Effective C++ 条款02: 尽量以const, enum, inline 替换#define&lt;/h1&gt;&lt;h2 id=&quot;1、-define-宏定义的记号名称从未被编译器看见&quot;&gt;&lt;a href=&quot;#1、-define-宏定义的记号名称从未被编译器看见&quot; class=&quot;headerlink&quot; title=&quot;1、#define  宏定义的记号名称从未被编译器看见&quot;&gt;&lt;/a&gt;1、#define  宏定义的记号名称从未被编译器看见&lt;/h2&gt;&lt;p&gt;【注意，作者这里没有称之为变量】&lt;br&gt;#define ASPECT_RATIO 1.653&lt;br&gt;ASPECT_RATIO这个记号也许从来就没有被编译器看见；也许在编译器开始处理源码之前他就被预处理器移走了。于是，ASPECT_RATIO根本没有进入符号表（symbol table）内。如果出现编译错误，可能编译器爆出的是1.653错了，。。。可能你压根想不到是自己定义的ASPECT_RATIO所指的意义。&lt;br&gt;预处理时会把源代码里的ASPECT_RATIO替换为 1.653，没有类型检查&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>how to post your first Hexo blog</title>
    <link href="http://jarvissky.com/2021/11/13/how-to-post-your-first-Hexo-blog/"/>
    <id>http://jarvissky.com/2021/11/13/how-to-post-your-first-Hexo-blog/</id>
    <published>2021-11-13T06:26:46.000Z</published>
    <updated>2021-11-13T07:37:02.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何用Hexo创建一个博客"><a href="#如何用Hexo创建一个博客" class="headerlink" title="如何用Hexo创建一个博客"></a>如何用Hexo创建一个博客</h1><p>[toc]</p><h2 id="0、用以下命令来创建一篇博客或者一个新的页面"><a href="#0、用以下命令来创建一篇博客或者一个新的页面" class="headerlink" title="0、用以下命令来创建一篇博客或者一个新的页面"></a>0、用以下命令来创建一篇博客或者一个新的页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout）,默认为post,可以通过_config.yml 中的 default_layout 参数来指定默认布局。</p><h2 id="1、布局"><a href="#1、布局" class="headerlink" title="1、布局"></a>1、布局</h2><p>Hexo 有三种默认的布局：post、page、draft</p><p>在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而你自定义的其他布局和post相同，都将存储到 source/_posts文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_post</td></tr><tr><td>page</td><td>soruce</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><p>这个一般用默认的时候</p><span id="more"></span><h2 id="2、文件名称"><a href="#2、文件名称" class="headerlink" title="2、文件名称"></a>2、文件名称</h2><p>Hexo 默认以标题作为文件名称，但你可以编辑 new_post_name 参数来改变默认的文件名称，例如：将文件名称设置为**:year-:month-:day-:title.md**可以让你更方便的通过日期来管理文章。</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>:title</td><td>标题，（小写，空格会被替换为横杠）</td></tr><tr><td>:year</td><td>建立年份</td></tr><tr><td>:month</td><td>建立月份（有前导0），比如四月：04</td></tr><tr><td>:i_month</td><td>建立月份（无前导0），比如四月：4</td></tr><tr><td>:day</td><td>建立日期（有前导0），比如七号：07</td></tr><tr><td>:i_day</td><td>建立日期（无前导0），比如七号：7</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="3、草稿"><a href="#3、草稿" class="headerlink" title="3、草稿"></a>3、草稿</h2><p>创建文稿时，Hexo的一种特殊布局时：draft,这种布局在建立时会被保存到 /source/_draft 文件夹内，可通过 <em>public</em>命令将草稿移动到 source/_post文件夹，该命令的使用方式与new十分类似，你也可以在命令中指定 layout 来定制布局方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，你可以在执行中加上 –draft 参数，或把 render_draft  参数设为 true 来预览草稿。</p><h2 id="4、模板（Scaffold）"><a href="#4、模板（Scaffold）" class="headerlink" title="4、模板（Scaffold）"></a>4、模板（Scaffold）</h2><p>在新建文章时，Hexo 会根据scaffolds 文件夹内响应的文件夹来建立文件，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new photo <span class="string">&quot;My Gallery&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这些命令时，Hexo会尝试在 scaffold文件夹中寻找 photo.md, 并根据其内容建立文章，以下时你可以在模板中使用的变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>layout</td><td>布局</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>date</td><td>文件建立日期</td></tr></tbody></table><h2 id="5、支持格式"><a href="#5、支持格式" class="headerlink" title="5、支持格式"></a>5、支持格式</h2><p>Hexo 支持以任何格式书写文章，只要安装了响应的渲染插件</p><p>Hexo，默认安装了 <strong>hexo-renderer-marked</strong> 和 <strong>hexo-renderer-ejs</strong>, 因此你不仅可以用markdown写作，还可以用EJS 写作。如果你安装了<strong>hexo-renderer-pug</strong>,你甚至可以使用Pug模板语法书写文章。</p><p>只需要将文章的扩展名从 md 改为 ejs, Hexo就会使用 hexo-renderer-ejs渲染整个文件，其它格式同理。</p><h2 id="6、front-matter"><a href="#6、front-matter" class="headerlink" title="6、front-matter"></a>6、front-matter</h2><p>front-matter是文件最上方以**—** 分割区域，用于指定个别文件的变量，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: how-to-post-your-first-Hexo-blog</span><br><span class="line">data: 2021/11/13</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预定义参数：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件的建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件的更新日期</td></tr><tr><td>comments</td><td>开启文章评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td></td></tr><tr><td>excerpt</td><td>页面期望用纯文本展示，用这个插件来格式化文本</td><td></td></tr><tr><td>disableNunjunks</td><td>禁止渲染 Numjunks tag,需要用到 tag plugins</td><td></td></tr><tr><td>lang</td><td>设置语言来覆盖自动检测的配置</td><td>继承与 _config.yml</td></tr></tbody></table><h2 id="7、分类和标签"><a href="#7、分类和标签" class="headerlink" title="7、分类和标签"></a>7、分类和标签</h2><p>只有文章支持分类和标签，你可以在front-matter中设置。在其他系统中分类和标签听起来很类似，但是Hexo中二者有明显的差别，分类具有顺序和层次性，也就是说Foo, Bar不等于Bar，Foo;而 标签没有顺序和层次。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> iOS</span><br><span class="line"><span class="bullet">-</span> Swift</span><br></pre></td></tr></table></figure><p>分类方法的分歧</p><p>wordpress中，一篇文章中可以设置多个分类，这些分类可以使同层级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line"><span class="bullet">-</span> Life</span><br></pre></td></tr></table></figure><p>上面的分类犯法会使 Lift成为Diary的子类，而不是并列分类。因此，有必要为你的文章尽可能准确的分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> [Diary, Eat]</span><br><span class="line"><span class="bullet">-</span> [Dirary, Games]</span><br><span class="line"><span class="bullet">-</span> [Lift]</span><br></pre></td></tr></table></figure><p>这时，这篇文章同时包含了三个分类：Diary,是一个分类，且有两个分类：Eat,Game.同时Life是一个没有子分类的分类。</p><h2 id="Json-front-matter"><a href="#Json-front-matter" class="headerlink" title="Json front-matter"></a>Json front-matter</h2><p>除了 YAML 外，你也可以 使用 JSON来编写 Front-matter，只要将 — 替换为 ；；；即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;title&quot;: &quot;title name&quot;</span><br><span class="line">&quot;date&quot;: &quot;20211113&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><h2 id="8、开始写文章"><a href="#8、开始写文章" class="headerlink" title="8、开始写文章"></a>8、开始写文章</h2><p>这样文章的标题和基本配置信息就搞定了。</p><p>剩下的就是根据markdown  语法写文章了</p><p>参考链接 <a href="https://hexo.io/zh-cn/docs/front-matter">hexo中文官方文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何用Hexo创建一个博客&quot;&gt;&lt;a href=&quot;#如何用Hexo创建一个博客&quot; class=&quot;headerlink&quot; title=&quot;如何用Hexo创建一个博客&quot;&gt;&lt;/a&gt;如何用Hexo创建一个博客&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;0、用以下命令来创建一篇博客或者一个新的页面&quot;&gt;&lt;a href=&quot;#0、用以下命令来创建一篇博客或者一个新的页面&quot; class=&quot;headerlink&quot; title=&quot;0、用以下命令来创建一篇博客或者一个新的页面&quot;&gt;&lt;/a&gt;0、用以下命令来创建一篇博客或者一个新的页面&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new [layout] &amp;lt;title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以在命令中指定文章的布局（layout）,默认为post,可以通过_config.yml 中的 default_layout 参数来指定默认布局。&lt;/p&gt;
&lt;h2 id=&quot;1、布局&quot;&gt;&lt;a href=&quot;#1、布局&quot; class=&quot;headerlink&quot; title=&quot;1、布局&quot;&gt;&lt;/a&gt;1、布局&lt;/h2&gt;&lt;p&gt;Hexo 有三种默认的布局：post、page、draft&lt;/p&gt;
&lt;p&gt;在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而你自定义的其他布局和post相同，都将存储到 source/_posts文件夹。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;布局&lt;/th&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;source/_post&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;soruce&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;draft&lt;/td&gt;
&lt;td&gt;source/_drafts&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;这个一般用默认的时候&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="http://jarvissky.com/categories/hexo/"/>
    
    <category term="create blog" scheme="http://jarvissky.com/categories/hexo/create-blog/"/>
    
    
    <category term="hexo" scheme="http://jarvissky.com/tags/hexo/"/>
    
    <category term="blog" scheme="http://jarvissky.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款01:视C++为一个语言联邦</title>
    <link href="http://jarvissky.com/2021/11/12/Effective-C-%E6%9D%A1%E6%AC%BE01-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/"/>
    <id>http://jarvissky.com/2021/11/12/Effective-C-%E6%9D%A1%E6%AC%BE01-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/</id>
    <published>2021-11-12T14:35:48.000Z</published>
    <updated>2021-11-26T14:39:47.936Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 是支持多重范性编程的语言<br>面向过程编程（procedural）<br>面向对象形式（object-oriented)<br>函数形式（functional)<br>范型形式（generic)<br>元编程形式（metaprogramming)</p><p>不同的编程模式需要遵循一些特定的规约，所以C++在不同的时候需要使用不同的规约特性：<br>最简单的方法是将C++视为一个由相关语言组成的联邦，而非单一语言。在其某个次语言sublanguage中，各种守则与通例都倾向简单、直观易懂、并且容易记住。<br>当你从一个次语言移往另一个次语言，守则可能改变。因此，为了理解C++,必须认识其主要的次语言。幸运的是总共只有4个。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>说到底C++仍是以C为基础。区块（blocks）,语句（statements)、预处理器（preprocessor)、内置类型（build-in data types)、数组（arrays）、指针（pointers）、等统统来自C。许多时候C++问题的解法其实不过就是较高级的C解法（例如条款2谈到预处理器之外的另一选择），条款13谈到以对象管理资源，当你以C++内的C成分工作时，高效守则映射出C语言的局限：没有模板（templates）,没有异常（exceptions),没有重载（overloading)…</p><span id="more"></span><h2 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h2><p>这部分也就是C with classes 所诉求的：classes（包括构造函数和析构函数），封装（encapsulation）,继承（inheritance）,多态（ploymorphism），virtual函数（动态绑定）等等。这一部分是面向对象设计之古典守则在C++上最直接实施。</p><h2 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h2><p>这是C++的范型编程（generic programming）部分，也是大多数程序员经验最少的部分。Template 相关考虑与设计已经弥漫整个C++,良好编程守则中”维template适用”的特殊条款并不罕见（例如条款46谈到调用template functions时如何协助类型转换）。实际上由于templates 威力强大，它们带来崭新的变成范型（programming paradigm）,也即是所谓的template metaprogramming（TMP,模板元编程）。条款48对此提供了一份概述，但除非你是template激进团队的中坚骨干，大可不必太担心这些。TMP相关规则很少与C++主流编程相互影响。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL是template程序库，但它非常特殊。它对容器（containers）、迭代器（iterators）、算法（algorithms）以及函数对象（function objects）的规约有极佳的紧密配合与协调，然而templates及程序库也可以其他想法建置起来。STL有自己特殊的办事方式，当你伙同STL一起工作，你必须遵守它的规约。</p><p>这四种次语言切换时规约会变，不必惊讶。<br>例如对内置类型而言（pass-by-value）通常比（pass-by-reference） 高效，但当你从C part of C++ 移往Object-Oriented C++,由于用户自定义（user-defined)构造函数和析构函数的存在，pass-by-reference-to-const往往更好。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦阔如STL你就会了解，迭代器和函数对象都是在C++指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的Cpass-by-value守则再次适用。（参数传递参照条款20）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ 是支持多重范性编程的语言&lt;br&gt;面向过程编程（procedural）&lt;br&gt;面向对象形式（object-oriented)&lt;br&gt;函数形式（functional)&lt;br&gt;范型形式（generic)&lt;br&gt;元编程形式（metaprogramming)&lt;/p&gt;
&lt;p&gt;不同的编程模式需要遵循一些特定的规约，所以C++在不同的时候需要使用不同的规约特性：&lt;br&gt;最简单的方法是将C++视为一个由相关语言组成的联邦，而非单一语言。在其某个次语言sublanguage中，各种守则与通例都倾向简单、直观易懂、并且容易记住。&lt;br&gt;当你从一个次语言移往另一个次语言，守则可能改变。因此，为了理解C++,必须认识其主要的次语言。幸运的是总共只有4个。&lt;/p&gt;
&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h2&gt;&lt;p&gt;说到底C++仍是以C为基础。区块（blocks）,语句（statements)、预处理器（preprocessor)、内置类型（build-in data types)、数组（arrays）、指针（pointers）、等统统来自C。许多时候C++问题的解法其实不过就是较高级的C解法（例如条款2谈到预处理器之外的另一选择），条款13谈到以对象管理资源，当你以C++内的C成分工作时，高效守则映射出C语言的局限：没有模板（templates）,没有异常（exceptions),没有重载（overloading)…&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://jarvissky.com/categories/C/"/>
    
    <category term="effective c++" scheme="http://jarvissky.com/categories/C/effective-c/"/>
    
    
    <category term="effective C++" scheme="http://jarvissky.com/tags/effective-C/"/>
    
  </entry>
  
  <entry>
    <title>swift GCD</title>
    <link href="http://jarvissky.com/2021/04/24/swift%20GCD/"/>
    <id>http://jarvissky.com/2021/04/24/swift%20GCD/</id>
    <published>2021-04-24T05:01:52.000Z</published>
    <updated>2021-04-24T11:02:58.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift5-x-中-GCD"><a href="#swift5-x-中-GCD" class="headerlink" title="swift5.x 中 GCD"></a>swift5.x 中 GCD</h1><p>[TOC]</p><p>swift 5.x对GCD封装了更加便捷的API,通过这些丰富的API,可以轻松实现多线程编程.</p><h2 id="0-队列和任务"><a href="#0-队列和任务" class="headerlink" title="0. 队列和任务"></a>0. 队列和任务</h2><p>在iOS多线程编程的术语里，最先要理解的两个概念就是队列和任务。</p><p>队列：就是任务执行的一个排队的空间。分为串行队列，并发队列。</p><p>任务：任务是计算机要处理的一段程序。</p><p>同步处理任务，就像是接力棒赛跑，上个人跑完了自己的路程，下个人继续下一段赛程，它有一个先后顺序。</p><p>异步处理任务，是针对多核计算机的，在单核计算机里是没有多线程的概念的，也就没有异步处理任务的说法，所有提交给CPU的任务，只有排队，一个个的处理。多核计算机异步处理任务，就是多个任务系统会统一调度，让CPU多个核心去同时处理多个任务。<strong>也是多线程编程的原因所在，多线程编程让充分发挥系统性能，提高程序运行效率。</strong>多线程编程就是程序员利用系统提供的API,根据业务要求编写出高效的程序。</p><p> 苹果提供的GCD便是一个多多线程编程的强大类库。</p><ol><li>GCD可用于多核的并行运算， </li><li>GCD会自动利用更多的CPU内核</li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li></ol><span id="more"></span><h2 id="1、swfit中用GCD创建一个队列"><a href="#1、swfit中用GCD创建一个队列" class="headerlink" title="1、swfit中用GCD创建一个队列"></a>1、swfit中用GCD创建一个队列</h2><h3 id="1-1-行队列的创建"><a href="#1-1-行队列的创建" class="headerlink" title="1.1 行队列的创建"></a>1.1 行队列的创建</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建</span></span><br><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>, qos: .default, attributes: .<span class="keyword">init</span>(rawValue: <span class="number">0</span>), autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//也可以简单些，除了指定一个label,其它的参数都可以使用一个默认值</span></span><br><span class="line"><span class="keyword">let</span> sQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(lable: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发队列的创建</span></span><br><span class="line"><span class="keyword">let</span> coucurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>, qos: .default, attributes: .coucurrent, autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明 </p><ul><li><p>label: 队列的名字，可以根据项目的bundleID 和功能模块来定义例如<em>com.wjw.SwiftTips.seraialQueue</em></p></li><li><p>qos:    服务质量优先级，队列的优先级。Objective-C中，有四种优先级分别是： </p><p>DISPATCH_<em>QUEUE</em>_PRIORITY_HIGHT</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_DEFAULT</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_LOW</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_BACKGROUND</p><p>而在swift中共有6中，默认是unspecified，其它几种和优先级排序是userInteractive &gt; userInitiated &gt; default &gt; utility &gt; background &gt; unspecified</p><p> public static let userInteractive: DispatchQoS 用户交互 </p><p>public static let userInitiated: DispatchQoS 用户发起</p><p> public static letdefault: DispatchQoS 默认优先级</p><p> public static let utility: DispatchQoS 对应oc中的low 低 </p><p>public static let background: DispatchQoS 后台 </p><p>public static let unspecified: DispatchQoS 不指定优先级</p></li><li><p>attributes: 指定队列性质，是串行队列还是并发队列</p><ul><li>concurrent: 表示队列是并行队列</li><li>没有该参数，默认创建的就是串行队列</li><li>initiallyInactive，标识队列中的任务不会自动执行，需要由队列的activate来触发，如果不添加该标识，队列中的任务会自动运行。</li></ul></li><li><p>autoreleaseFrequency： 类型为枚举类型，用来管理任务内对象的生命周期的自动释放的频率</p><ul><li>inherit: 继承目标队列的该属性</li><li>workItem: 跟随每个任务的执行周期进行自动创建和释放</li><li>nerver: 不会创建自动释放池</li></ul><p>一般用workItem即可，不指定target参数时，应该是系统管理释放频率。</p></li><li><p>target: 设置队列的目标队列，即队列中的任务运行时，实际所在的队列。目标队列最终决定了队列的优先级等级。</p><p>在程序中手动创建的队列最终都指向了系统自带的主队列或全局并发队列。</p></li></ul><h3 id="1-2-系统队列"><a href="#1-2-系统队列" class="headerlink" title="1.2 系统队列"></a>1.2 系统队列</h3><h4 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h4><p>一切UI线程的刷新都在主线程中进行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个主队列</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main</span><br></pre></td></tr></table></figure><h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取全局队列</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>我们一般的需要在子线程中进行处理的耗时任务都可以在全局队列中进行。不过也有例外，有时我们利用全局队列反而会发生一些意料不到的问题。后面会讲到。</p><h2 id="2、在一个队列中执行任务"><a href="#2、在一个队列中执行任务" class="headerlink" title="2、在一个队列中执行任务"></a>2、在一个队列中执行任务</h2><p>任务的执行分为 同步执行和异步执行</p><h3 id="2-1-在主队列中执行任务"><a href="#2-1-在主队列中执行任务" class="headerlink" title="2.1 在主队列中执行任务"></a>2.1 在主队列中执行任务</h3><p>我们不做任何处理，在viewDidload 里写的这些代码默认都是在主队列里执行的，这也是为什么页面复杂的时候，加载页面会出现卡顿的原因所在。</p><p>以下代码是绝对不允许直接出现的，在主队列（由于主队列只有一个线程同步执行，我们也叫它主线程）中同步处理任务会造成死锁。</p><p>主线程中的任务都是同步执行的，下面的同步任务执行需要等待主线程让出资源，但是主线程是内存常驻的，它管理整个程序的UI加载刷新，是不可能让出的,主线程完成了应用就退出了，让同步的让主线程执行自定义的打印任务就会一直得不到资源，造成死锁。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程同步执行一个任务【会造成死锁】</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;主队列 同步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程异步执行一个任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;主队列 异步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-在全局队列中执行任务"><a href="#2-2-在全局队列中执行任务" class="headerlink" title="2.2 在全局队列中执行任务"></a>2.2 在全局队列中执行任务</h3><p>在全局队列中同步执行一个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局队列中同步执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;全局队列 同步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局队列中异步执行任务，会自动管理任务的执行，要不要直接在全局队列中执行，还是由全局队列再创建新的线程执行。我们都不用再操心了。</p><p>全局队列中异步执行一个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局队列中异步执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;全局队列 异步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这里需要补充一下 全局队列异步执行多个任务，barrier是没有用的。正如我们上面提到的，全局队列为了执行效率，并没有检查 barrier。</p><h2 id="3、串行并行嵌套问题"><a href="#3、串行并行嵌套问题" class="headerlink" title="3、串行并行嵌套问题"></a>3、串行并行嵌套问题</h2><h3 id="3-1-串行队列中同步执行任务"><a href="#3-1-串行队列中同步执行任务" class="headerlink" title="3.1 串行队列中同步执行任务"></a>3.1 串行队列中同步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列 同步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">serialQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;串行队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;串行队列1&quot;</span>, qos: .default, attributes: .<span class="keyword">init</span>(rawValue: <span class="number">0</span>), autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">            serialQueue.async &#123;</span><br><span class="line">                sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码会依次输入0到9</p><p>可见，串行队列中同步执行和我们平日里写一个for循环是一样的。并没有体现多线程编程的优越性，由于我们让打印随机延时输出，会发现打印全的时间是全部随机时间之和。没有提高效率。</p><h3 id="3-2-串行队列中异步执行任务"><a href="#3-2-串行队列中异步执行任务" class="headerlink" title="3.2 串行队列中异步执行任务"></a>3.2 串行队列中异步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列， 异步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">serialQueueAsyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;串行队列+异步任务——开启一个新线程依次执行&quot;</span>)</span><br><span class="line">  <span class="comment">//串行队列</span></span><br><span class="line">  <span class="keyword">let</span> serial <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;串行队列2&quot;</span>,attributes: .<span class="keyword">init</span>(rawValue:<span class="number">0</span>))</span><br><span class="line">  <span class="built_in">print</span>(<span class="type">Thread</span>.current)<span class="comment">//主线程</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    serial.async &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)<span class="comment">//子线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现，打印速度比第一种情况要快。主线程打印的  NSThread ，number == 1， 新创建的线程是number == 35，可见异步编程提高了程序运行效率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">串行队列+异步任务——开启一个新线程依次执行</span><br><span class="line">&lt;NSThread: 0x600003520140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">0 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">1 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">2 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">3 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">4 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">5 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">6 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">7 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">8 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">9 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">10 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-并行队列中同步执行任务"><a href="#3-3-并行队列中同步执行任务" class="headerlink" title="3.3 并行队列中同步执行任务"></a>3.3 并行队列中同步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+同步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;并发队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">  <span class="comment">//以下代码输出顺序始终为0...10,且线程始终为主线程</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().sync &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，全局队列中同步执行任务，会在主线程中依次执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列+同步任务——依次执行</span><br><span class="line">0 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">6 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">7 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">8 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">9 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">10 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个并发队列，然后同步执行</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+同步执行</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;并发队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">        <span class="comment">//以下代码输出顺序始终为0...10,且线程始终为主线程</span></span><br><span class="line">        <span class="keyword">let</span> conQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.swiftTips.concurrentQueue&quot;</span>, qos: .default, attributes: .concurrent  , autoreleaseFrequency: .workItem, target: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">            conQueue.sync &#123;</span><br><span class="line">                sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">                <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果依旧是这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">并发队列+同步任务——依次执行</span><br><span class="line">0 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">6 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">7 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">8 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">9 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">10 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由以上可以确定，就是是并发队列，同步执行的任务，只会在主线程中依次执行。</p><h3 id="3-4-并行队列中异步执行任务"><a href="#3-4-并行队列中异步执行任务" class="headerlink" title="3.4 并行队列中异步执行任务"></a>3.4 并行队列中异步执行任务</h3><p>全局队列中异步执行多个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+异步任务</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueAsyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;并发队列+异步任务  开启多个线程并发执行&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现打印结果迅速，并不会像第一种情形，每次打印都等待随机延迟时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列+异步任务——开启多个线程并发执行</span><br><span class="line">0 &lt;NSThread: 0x600003031280&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2 &lt;NSThread: 0x600003005c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">3 &lt;NSThread: 0x600003008880&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">5 &lt;NSThread: 0x600003006280&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">8 &lt;NSThread: 0x600003007380&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">9 &lt;NSThread: 0x600003048e80&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">1 &lt;NSThread: 0x60000306c440&gt;&#123;number = 13, name = (null)&#125;</span><br><span class="line">4 &lt;NSThread: 0x600003031280&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">7 &lt;NSThread: 0x600003005c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">10 &lt;NSThread: 0x600003008880&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">6 &lt;NSThread: 0x600003074300&gt;&#123;number = 14, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>是并发+异步编程提升了程序的处理效率。</p><p>实际上，同步就是在当前线程中执行任务。异步就是GCD会创建新的线程，在多个cpu核心里执行任务。从而利用硬件性能，提高程序运行效率。</p><p>关于队列的串行，并行网上许多资料也提到，并行叫并发更合适。</p><p>并发字面意思体现在这些多个任务同时被提交给CPU,它们的执行期间并排执行的时间差异很大时，并行的描述并不形象。例如一个1ms执行完的任务和一个10min执行的任务并行执行的时间只有1ms，但是说成是并发，就可以理解为他们一同出发，谁先到达终点，我们就不用管了，也管不了。</p><p>当然这都是些文字游戏，主要能帮我们加深理解。</p><h2 id="4、GCD-group"><a href="#4、GCD-group" class="headerlink" title="4、GCD group"></a>4、GCD group</h2><h3 id="4-1-GCD-group的使用"><a href="#4-1-GCD-group的使用" class="headerlink" title="4.1 GCD group的使用"></a>4.1 GCD group的使用</h3><p>实际开发当中，由于异步执行结束的时间不确定，我们在很多场景下会遇到要求任务A，B执行完以后，任务C才执行。A,B这类任务是前置任务，C是后置任务。为满足这样的场景。利用group就可以很方便的实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">groupTest1</span>()</span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;gcd group的使用&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">  <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务A-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务B-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务C-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//group完成时，指定在某个队列中执行一个后续任务</span></span><br><span class="line">  group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group中所有的任务都完成了,执行此处操作&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，group结束时，可以用notify和wait来通知任务执行完的状态,其中，notify不能设置超时时间，而wait可以。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> group.wait(timeout: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> .success:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;group 执行完成&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .timedOut:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;group 执行超时&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-group-enter-group-leave"><a href="#4-2-group-enter-group-leave" class="headerlink" title="4.2 group.enter(), group.leave()"></a>4.2 group.enter(), group.leave()</h3><p>group.enter() 和 group.leave() 必须成对出现。</p><p>group.enter() 出现在任务执行开始前，group.leave() 出现在任务执行结束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">groupTest2</span>()</span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;gcd group的使用&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务A-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务B-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务C-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group中所有的任务都完成了&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来和不加enter,leave并没有太大区别，但是第一个示例，我们的任务都是在自己定义的队列里执行。倘若，我们的拿不到执行任务的队列，比如执行任务的队列是第三方库提供的。我们就需要用到这一对操作。</p><h2 id="5-延迟执行-asyncAfter"><a href="#5-延迟执行-asyncAfter" class="headerlink" title="5. 延迟执行 asyncAfter"></a>5. 延迟执行 asyncAfter</h2><p>延迟执行很简单，利用asyncAfter 即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">dispatchAfter</span>()</span> &#123;</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().asyncAfter(deadline: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span> ) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">5</span>, <span class="string">&quot;秒之后执行&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、信号量"><a href="#6、信号量" class="headerlink" title="6、信号量"></a>6、信号量</h2><p>信号量是多线程编程中标识可用资源数。 由于计算机必须具备了可用资源才能执行程序，我们可以利用信号量这一特点，需求来完成一些骚操作。</p><ol><li><p>信号量的创建  let semaphore = DispatchSemaphore.init(value: 0)</p></li><li><p>信号量的-1 wait   semaphore.wait() </p><p>信号量&gt;0时，可以执行代码区，并把信号量-1，当信号量为0时，后续提交的任务都要等待。</p></li><li><p>信号量的+1   semaphore.singnal()</p><p>代码区执行完信号量+1</p></li></ol><ul><li><p>信号量可以处理异步任务的同步</p><p>我们把信号量设置为0，完成任务时发送一次信号，标识只有一个可用资源，那么其它线程执行到这里就只能放行一个，完成了-1.从而达到把异步任务同步化的目的。这里把异步任务同步化处理一般是为了满足具体的业务需求，并不会和异步编程能提高程序运行效率相矛盾。</p></li><li><p>设置异步线程的最大任务并发数max</p><p>把信号量的值设置为最大并发数，执行任务前先-1， 完成了+1；当提交的任务数大于max，时，只要执行中的任务还没有释放资源，就不会再有新的任务执行。</p></li><li><p>设置锁</p><p>把信号量的值设置为1，执行任务时，先-1，就可以阻塞当前线程，</p></li></ul><h3 id="6-1-信号量处理同步"><a href="#6-1-信号量处理同步" class="headerlink" title="6.1 信号量处理同步"></a>6.1 信号量处理同步</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量处理同步</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreSync</span>()</span> &#123;</span><br><span class="line">  <span class="comment">//创建信号量为0</span></span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">0</span>)</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">    sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)</span><br><span class="line">    <span class="comment">//信号量+1</span></span><br><span class="line">    semaphore.signal()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待，信号量大于0，可以继续执行并将信号量-1，信号量=0,阻塞</span></span><br><span class="line">  <span class="keyword">switch</span> semaphore.wait(timeout: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> .success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信号量控制的同步任务完成&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .timedOut:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信号量控制的同步任务超时&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-信号量控制最大并发量"><a href="#6-2-信号量控制最大并发量" class="headerlink" title="6.2 信号量控制最大并发量"></a>6.2 信号量控制最大并发量</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量控制最大并发量</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreMaxConcurrent</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;信号量控制最大并发量&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span> &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">      sleep(arc4random() <span class="operator">%</span> <span class="number">3</span>)</span><br><span class="line">      <span class="built_in">print</span>(i, <span class="type">Thread</span>.current)</span><br><span class="line">      semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-锁"><a href="#6-3-锁" class="headerlink" title="6.3 锁"></a>6.3 锁</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>信号量枷锁</span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreAsLock</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;信号量枷锁&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">1</span>)</span><br><span class="line">  semaphore.wait()</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模拟任务&quot;</span>, <span class="type">Thread</span>.current)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;swift5-x-中-GCD&quot;&gt;&lt;a href=&quot;#swift5-x-中-GCD&quot; class=&quot;headerlink&quot; title=&quot;swift5.x 中 GCD&quot;&gt;&lt;/a&gt;swift5.x 中 GCD&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;swift 5.x对GCD封装了更加便捷的API,通过这些丰富的API,可以轻松实现多线程编程.&lt;/p&gt;
&lt;h2 id=&quot;0-队列和任务&quot;&gt;&lt;a href=&quot;#0-队列和任务&quot; class=&quot;headerlink&quot; title=&quot;0. 队列和任务&quot;&gt;&lt;/a&gt;0. 队列和任务&lt;/h2&gt;&lt;p&gt;在iOS多线程编程的术语里，最先要理解的两个概念就是队列和任务。&lt;/p&gt;
&lt;p&gt;队列：就是任务执行的一个排队的空间。分为串行队列，并发队列。&lt;/p&gt;
&lt;p&gt;任务：任务是计算机要处理的一段程序。&lt;/p&gt;
&lt;p&gt;同步处理任务，就像是接力棒赛跑，上个人跑完了自己的路程，下个人继续下一段赛程，它有一个先后顺序。&lt;/p&gt;
&lt;p&gt;异步处理任务，是针对多核计算机的，在单核计算机里是没有多线程的概念的，也就没有异步处理任务的说法，所有提交给CPU的任务，只有排队，一个个的处理。多核计算机异步处理任务，就是多个任务系统会统一调度，让CPU多个核心去同时处理多个任务。&lt;strong&gt;也是多线程编程的原因所在，多线程编程让充分发挥系统性能，提高程序运行效率。&lt;/strong&gt;多线程编程就是程序员利用系统提供的API,根据业务要求编写出高效的程序。&lt;/p&gt;
&lt;p&gt; 苹果提供的GCD便是一个多多线程编程的强大类库。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCD可用于多核的并行运算， &lt;/li&gt;
&lt;li&gt;GCD会自动利用更多的CPU内核&lt;/li&gt;
&lt;li&gt;GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://jarvissky.com/categories/iOS/"/>
    
    <category term="swift" scheme="http://jarvissky.com/categories/iOS/swift/"/>
    
    
    <category term="swift" scheme="http://jarvissky.com/tags/swift/"/>
    
    <category term="GCD" scheme="http://jarvissky.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>swift 可选值</title>
    <link href="http://jarvissky.com/2021/04/04/swift-%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    <id>http://jarvissky.com/2021/04/04/swift-%E5%8F%AF%E9%80%89%E5%80%BC/</id>
    <published>2021-04-04T09:10:51.000Z</published>
    <updated>2021-04-05T06:22:18.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift-可选值"><a href="#swift-可选值" class="headerlink" title="swift 可选值"></a>swift 可选值</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>swift 是苹果的二儿子，和大儿子OC比起来有很多优势，他更加接近现代编程语言的范式，类似解释语言的语法习惯，却是名副其实的强类型语言。接触最初就会遇到一个swift和OC明显不同的数据类型，<strong>可选值 | Optional Value</strong>。</p><p>中文翻译直接理解的话就是可以选来用也可以不选。个人认为把他理解为未定型更合符合普通的思维习惯,有点像JavaScript中的未定型。</p> <span id="more"></span><p>我们可以这样声明一个可选值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name : String?</span><br></pre></td></tr></table></figure><p>用标识符var 声明一个变量 name ，后面的？表示它是一个可选值。在后续使用中它的值可能是字符串 “张三”。也可能是一个空值 nil 。</p><p>这里有一点和OC不同的是，OC中的基本数据类型都会有默认的初始值，例如 NSInter 默认为0，CGFloat 默认为 0.0。但是swift里由于可选值概念的存在，基础数据类型（int, double, bool）没有值时也可以是nil.<br>一个可选值没有初始值的话是不可以使用的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;swift-可选值&quot;&gt;&lt;a href=&quot;#swift-可选值&quot; class=&quot;headerlink&quot; title=&quot;swift 可选值&quot;&gt;&lt;/a&gt;swift 可选值&lt;/h1&gt;&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h2&gt;&lt;p&gt;swift 是苹果的二儿子，和大儿子OC比起来有很多优势，他更加接近现代编程语言的范式，类似解释语言的语法习惯，却是名副其实的强类型语言。接触最初就会遇到一个swift和OC明显不同的数据类型，&lt;strong&gt;可选值 | Optional Value&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;中文翻译直接理解的话就是可以选来用也可以不选。个人认为把他理解为未定型更合符合普通的思维习惯,有点像JavaScript中的未定型。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://jarvissky.com/categories/iOS/"/>
    
    <category term="swift" scheme="http://jarvissky.com/categories/iOS/swift/"/>
    
    
    <category term="swift" scheme="http://jarvissky.com/tags/swift/"/>
    
    <category term="可选值" scheme="http://jarvissky.com/tags/%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jarvissky.com/2021/04/04/hello-world/"/>
    <id>http://jarvissky.com/2021/04/04/hello-world/</id>
    <published>2021-04-04T03:51:04.346Z</published>
    <updated>2021-04-05T06:10:16.637Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://jarvissky.com/tags/hexo/"/>
    
  </entry>
  
</feed>
