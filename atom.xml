<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jarvis的天空</title>
  
  <subtitle>闲云野鹤</subtitle>
  <link href="http://jarvissky.com/atom.xml" rel="self"/>
  
  <link href="http://jarvissky.com/"/>
  <updated>2021-11-13T07:34:14.630Z</updated>
  <id>http://jarvissky.com/</id>
  
  <author>
    <name>Jarvis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how to post your first Hexo blog</title>
    <link href="http://jarvissky.com/2021/11/13/how-to-post-your-first-Hexo-blog/"/>
    <id>http://jarvissky.com/2021/11/13/how-to-post-your-first-Hexo-blog/</id>
    <published>2021-11-13T06:26:46.000Z</published>
    <updated>2021-11-13T07:34:14.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何用Hexo创建一个博客"><a href="#如何用Hexo创建一个博客" class="headerlink" title="如何用Hexo创建一个博客"></a>如何用Hexo创建一个博客</h1><p>[toc]</p><h2 id="0、用以下命令来创建一篇博客或者一个新的页面"><a href="#0、用以下命令来创建一篇博客或者一个新的页面" class="headerlink" title="0、用以下命令来创建一篇博客或者一个新的页面"></a>0、用以下命令来创建一篇博客或者一个新的页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout）,默认为post,可以通过_config.yml 中的 default_layout 参数来指定默认布局。</p><h2 id="1、布局"><a href="#1、布局" class="headerlink" title="1、布局"></a>1、布局</h2><p>Hexo 有三种默认的布局：post、page、draft</p><p>在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而你自定义的其他布局和post相同，都将存储到 source/_posts文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_post</td></tr><tr><td>page</td><td>soruce</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><p>这个一般用默认的时候</p><h2 id="2、文件名称"><a href="#2、文件名称" class="headerlink" title="2、文件名称"></a>2、文件名称</h2><p>Hexo 默认以标题作为文件名称，但你可以编辑 new_post_name 参数来改变默认的文件名称，例如：将文件名称设置为**:year-:month-:day-:title.md**可以让你更方便的通过日期来管理文章。</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>:title</td><td>标题，（小写，空格会被替换为横杠）</td></tr><tr><td>:year</td><td>建立年份</td></tr><tr><td>:month</td><td>建立月份（有前导0），比如四月：04</td></tr><tr><td>:i_month</td><td>建立月份（无前导0），比如四月：4</td></tr><tr><td>:day</td><td>建立日期（有前导0），比如七号：07</td></tr><tr><td>:i_day</td><td>建立日期（无前导0），比如七号：7</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="3、草稿"><a href="#3、草稿" class="headerlink" title="3、草稿"></a>3、草稿</h2><p>创建文稿时，Hexo的一种特殊布局时：draft,这种布局在建立时会被保存到 /source/_draft 文件夹内，可通过 <em>public</em>命令将草稿移动到 source/_post文件夹，该命令的使用方式与new十分类似，你也可以在命令中指定 layout 来定制布局方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，你可以在执行中加上 –draft 参数，或把 render_draft  参数设为 true 来预览草稿。</p><h2 id="4、模板（Scaffold）"><a href="#4、模板（Scaffold）" class="headerlink" title="4、模板（Scaffold）"></a>4、模板（Scaffold）</h2><p>在新建文章时，Hexo 会根据scaffolds 文件夹内响应的文件夹来建立文件，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new photo <span class="string">&quot;My Gallery&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这些命令时，Hexo会尝试在 scaffold文件夹中寻找 photo.md, 并根据其内容建立文章，以下时你可以在模板中使用的变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>layout</td><td>布局</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>date</td><td>文件建立日期</td></tr></tbody></table><h2 id="5、支持格式"><a href="#5、支持格式" class="headerlink" title="5、支持格式"></a>5、支持格式</h2><p>Hexo 支持以任何格式书写文章，只要安装了响应的渲染插件</p><p>Hexo，默认安装了 <strong>hexo-renderer-marked</strong> 和 <strong>hexo-renderer-ejs</strong>, 因此你不仅可以用markdown写作，还可以用EJS 写作。如果你安装了<strong>hexo-renderer-pug</strong>,你甚至可以使用Pug模板语法书写文章。</p><p>只需要将文章的扩展名从 md 改为 ejs, Hexo就会使用 hexo-renderer-ejs渲染整个文件，其它格式同理。</p><h2 id="6、front-matter"><a href="#6、front-matter" class="headerlink" title="6、front-matter"></a>6、front-matter</h2><p>front-matter是文件最上方以**—** 分割区域，用于指定个别文件的变量，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: how-to-post-your-first-Hexo-blog</span><br><span class="line">data: 2021/11/13</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预定义参数：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件的建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件的更新日期</td></tr><tr><td>comments</td><td>开启文章评论功能</td><td>true</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td></td></tr><tr><td>excerpt</td><td>页面期望用纯文本展示，用这个插件来格式化文本</td><td></td></tr><tr><td>disableNunjunks</td><td>禁止渲染 Numjunks tag,需要用到 tag plugins</td><td></td></tr><tr><td>lang</td><td>设置语言来覆盖自动检测的配置</td><td>继承与 _config.yml</td></tr></tbody></table><h2 id="7、分类和标签"><a href="#7、分类和标签" class="headerlink" title="7、分类和标签"></a>7、分类和标签</h2><p>只有文章支持分类和标签，你可以在front-matter中设置。在其他系统中分类和标签听起来很类似，但是Hexo中二者有明显的差别，分类具有顺序和层次性，也就是说Foo, Bar不等于Bar，Foo;而 标签没有顺序和层次。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> iOS</span><br><span class="line"><span class="bullet">-</span> Swift</span><br></pre></td></tr></table></figure><p>分类方法的分歧</p><p>wordpress中，一篇文章中可以设置多个分类，这些分类可以使同层级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line"><span class="bullet">-</span> Life</span><br></pre></td></tr></table></figure><p>上面的分类犯法会使 Lift成为Diary的子类，而不是并列分类。因此，有必要为你的文章尽可能准确的分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> [Diary, Eat]</span><br><span class="line"><span class="bullet">-</span> [Dirary, Games]</span><br><span class="line"><span class="bullet">-</span> [Lift]</span><br></pre></td></tr></table></figure><p>这时，这篇文章同时包含了三个分类：Diary,是一个分类，且有两个分类：Eat,Game.同时Life是一个没有子分类的分类。</p><h2 id="Json-front-matter"><a href="#Json-front-matter" class="headerlink" title="Json front-matter"></a>Json front-matter</h2><p>除了 YAML 外，你也可以 使用 JSON来编写 Front-matter，只要将 — 替换为 ；；；即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;title&quot;: &quot;title name&quot;</span><br><span class="line">&quot;date&quot;: &quot;20211113&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><h2 id="8、开始写文章"><a href="#8、开始写文章" class="headerlink" title="8、开始写文章"></a>8、开始写文章</h2><p>这样文章的标题和基本配置信息就搞定了。</p><p>剩下的就是根据markdown  语法写文章了</p><p>参考链接 <a href="https://hexo.io/zh-cn/docs/front-matter">hexo中文官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何用Hexo创建一个博客&quot;&gt;&lt;a href=&quot;#如何用Hexo创建一个博客&quot; class=&quot;headerlink&quot; title=&quot;如何用Hexo创建一个博客&quot;&gt;&lt;/a&gt;如何用Hexo创建一个博客&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;0、用以下命令来</summary>
      
    
    
    
    <category term="hexo" scheme="http://jarvissky.com/categories/hexo/"/>
    
    <category term="create blog" scheme="http://jarvissky.com/categories/hexo/create-blog/"/>
    
    
    <category term="hexo" scheme="http://jarvissky.com/tags/hexo/"/>
    
    <category term="blog" scheme="http://jarvissky.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>swift GCD</title>
    <link href="http://jarvissky.com/2021/04/24/swift%20GCD/"/>
    <id>http://jarvissky.com/2021/04/24/swift%20GCD/</id>
    <published>2021-04-24T05:01:52.000Z</published>
    <updated>2021-04-24T11:02:58.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift5-x-中-GCD"><a href="#swift5-x-中-GCD" class="headerlink" title="swift5.x 中 GCD"></a>swift5.x 中 GCD</h1><p>[TOC]</p><p>swift 5.x对GCD封装了更加便捷的API,通过这些丰富的API,可以轻松实现多线程编程.</p><h2 id="0-队列和任务"><a href="#0-队列和任务" class="headerlink" title="0. 队列和任务"></a>0. 队列和任务</h2><p>在iOS多线程编程的术语里，最先要理解的两个概念就是队列和任务。</p><p>队列：就是任务执行的一个排队的空间。分为串行队列，并发队列。</p><p>任务：任务是计算机要处理的一段程序。</p><p>同步处理任务，就像是接力棒赛跑，上个人跑完了自己的路程，下个人继续下一段赛程，它有一个先后顺序。</p><p>异步处理任务，是针对多核计算机的，在单核计算机里是没有多线程的概念的，也就没有异步处理任务的说法，所有提交给CPU的任务，只有排队，一个个的处理。多核计算机异步处理任务，就是多个任务系统会统一调度，让CPU多个核心去同时处理多个任务。<strong>也是多线程编程的原因所在，多线程编程让充分发挥系统性能，提高程序运行效率。</strong>多线程编程就是程序员利用系统提供的API,根据业务要求编写出高效的程序。</p><p> 苹果提供的GCD便是一个多多线程编程的强大类库。</p><ol><li>GCD可用于多核的并行运算， </li><li>GCD会自动利用更多的CPU内核</li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li></ol><span id="more"></span><h2 id="1、swfit中用GCD创建一个队列"><a href="#1、swfit中用GCD创建一个队列" class="headerlink" title="1、swfit中用GCD创建一个队列"></a>1、swfit中用GCD创建一个队列</h2><h3 id="1-1-行队列的创建"><a href="#1-1-行队列的创建" class="headerlink" title="1.1 行队列的创建"></a>1.1 行队列的创建</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建</span></span><br><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>, qos: .default, attributes: .<span class="keyword">init</span>(rawValue: <span class="number">0</span>), autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//也可以简单些，除了指定一个label,其它的参数都可以使用一个默认值</span></span><br><span class="line"><span class="keyword">let</span> sQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(lable: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发队列的创建</span></span><br><span class="line"><span class="keyword">let</span> coucurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.SwiftTips.seraialQueue&quot;</span>, qos: .default, attributes: .coucurrent, autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明 </p><ul><li><p>label: 队列的名字，可以根据项目的bundleID 和功能模块来定义例如<em>com.wjw.SwiftTips.seraialQueue</em></p></li><li><p>qos:    服务质量优先级，队列的优先级。Objective-C中，有四种优先级分别是： </p><p>DISPATCH_<em>QUEUE</em>_PRIORITY_HIGHT</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_DEFAULT</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_LOW</p><p> DISPATCH_<em>QUEUE</em>_PRIORITY_BACKGROUND</p><p>而在swift中共有6中，默认是unspecified，其它几种和优先级排序是userInteractive &gt; userInitiated &gt; default &gt; utility &gt; background &gt; unspecified</p><p> public static let userInteractive: DispatchQoS 用户交互 </p><p>public static let userInitiated: DispatchQoS 用户发起</p><p> public static letdefault: DispatchQoS 默认优先级</p><p> public static let utility: DispatchQoS 对应oc中的low 低 </p><p>public static let background: DispatchQoS 后台 </p><p>public static let unspecified: DispatchQoS 不指定优先级</p></li><li><p>attributes: 指定队列性质，是串行队列还是并发队列</p><ul><li>concurrent: 表示队列是并行队列</li><li>没有该参数，默认创建的就是串行队列</li><li>initiallyInactive，标识队列中的任务不会自动执行，需要由队列的activate来触发，如果不添加该标识，队列中的任务会自动运行。</li></ul></li><li><p>autoreleaseFrequency： 类型为枚举类型，用来管理任务内对象的生命周期的自动释放的频率</p><ul><li>inherit: 继承目标队列的该属性</li><li>workItem: 跟随每个任务的执行周期进行自动创建和释放</li><li>nerver: 不会创建自动释放池</li></ul><p>一般用workItem即可，不指定target参数时，应该是系统管理释放频率。</p></li><li><p>target: 设置队列的目标队列，即队列中的任务运行时，实际所在的队列。目标队列最终决定了队列的优先级等级。</p><p>在程序中手动创建的队列最终都指向了系统自带的主队列或全局并发队列。</p></li></ul><h3 id="1-2-系统队列"><a href="#1-2-系统队列" class="headerlink" title="1.2 系统队列"></a>1.2 系统队列</h3><h4 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h4><p>一切UI线程的刷新都在主线程中进行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个主队列</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main</span><br></pre></td></tr></table></figure><h4 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取全局队列</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>我们一般的需要在子线程中进行处理的耗时任务都可以在全局队列中进行。不过也有例外，有时我们利用全局队列反而会发生一些意料不到的问题。后面会讲到。</p><h2 id="2、在一个队列中执行任务"><a href="#2、在一个队列中执行任务" class="headerlink" title="2、在一个队列中执行任务"></a>2、在一个队列中执行任务</h2><p>任务的执行分为 同步执行和异步执行</p><h3 id="2-1-在主队列中执行任务"><a href="#2-1-在主队列中执行任务" class="headerlink" title="2.1 在主队列中执行任务"></a>2.1 在主队列中执行任务</h3><p>我们不做任何处理，在viewDidload 里写的这些代码默认都是在主队列里执行的，这也是为什么页面复杂的时候，加载页面会出现卡顿的原因所在。</p><p>以下代码是绝对不允许直接出现的，在主队列（由于主队列只有一个线程同步执行，我们也叫它主线程）中同步处理任务会造成死锁。</p><p>主线程中的任务都是同步执行的，下面的同步任务执行需要等待主线程让出资源，但是主线程是内存常驻的，它管理整个程序的UI加载刷新，是不可能让出的,主线程完成了应用就退出了，让同步的让主线程执行自定义的打印任务就会一直得不到资源，造成死锁。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程同步执行一个任务【会造成死锁】</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;主队列 同步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程异步执行一个任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;主队列 异步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-在全局队列中执行任务"><a href="#2-2-在全局队列中执行任务" class="headerlink" title="2.2 在全局队列中执行任务"></a>2.2 在全局队列中执行任务</h3><p>在全局队列中同步执行一个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局队列中同步执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().sync &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;全局队列 同步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局队列中异步执行任务，会自动管理任务的执行，要不要直接在全局队列中执行，还是由全局队列再创建新的线程执行。我们都不用再操心了。</p><p>全局队列中异步执行一个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局队列中异步执行任务</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;全局队列 异步执行任务&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这里需要补充一下 全局队列异步执行多个任务，barrier是没有用的。正如我们上面提到的，全局队列为了执行效率，并没有检查 barrier。</p><h2 id="3、串行并行嵌套问题"><a href="#3、串行并行嵌套问题" class="headerlink" title="3、串行并行嵌套问题"></a>3、串行并行嵌套问题</h2><h3 id="3-1-串行队列中同步执行任务"><a href="#3-1-串行队列中同步执行任务" class="headerlink" title="3.1 串行队列中同步执行任务"></a>3.1 串行队列中同步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列 同步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">serialQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;串行队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;串行队列1&quot;</span>, qos: .default, attributes: .<span class="keyword">init</span>(rawValue: <span class="number">0</span>), autoreleaseFrequency: .inherit, target: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">            serialQueue.async &#123;</span><br><span class="line">                sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码会依次输入0到9</p><p>可见，串行队列中同步执行和我们平日里写一个for循环是一样的。并没有体现多线程编程的优越性，由于我们让打印随机延时输出，会发现打印全的时间是全部随机时间之和。没有提高效率。</p><h3 id="3-2-串行队列中异步执行任务"><a href="#3-2-串行队列中异步执行任务" class="headerlink" title="3.2 串行队列中异步执行任务"></a>3.2 串行队列中异步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列， 异步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">serialQueueAsyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;串行队列+异步任务——开启一个新线程依次执行&quot;</span>)</span><br><span class="line">  <span class="comment">//串行队列</span></span><br><span class="line">  <span class="keyword">let</span> serial <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;串行队列2&quot;</span>,attributes: .<span class="keyword">init</span>(rawValue:<span class="number">0</span>))</span><br><span class="line">  <span class="built_in">print</span>(<span class="type">Thread</span>.current)<span class="comment">//主线程</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    serial.async &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)<span class="comment">//子线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现，打印速度比第一种情况要快。主线程打印的  NSThread ，number == 1， 新创建的线程是number == 35，可见异步编程提高了程序运行效率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">串行队列+异步任务——开启一个新线程依次执行</span><br><span class="line">&lt;NSThread: 0x600003520140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">0 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">1 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">2 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">3 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">4 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">5 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">6 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">7 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">8 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">9 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">10 &lt;NSThread: 0x6000035a9d40&gt;&#123;number = 35, name = (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-并行队列中同步执行任务"><a href="#3-3-并行队列中同步执行任务" class="headerlink" title="3.3 并行队列中同步执行任务"></a>3.3 并行队列中同步执行任务</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+同步执行</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;并发队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">  <span class="comment">//以下代码输出顺序始终为0...10,且线程始终为主线程</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().sync &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，全局队列中同步执行任务，会在主线程中依次执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列+同步任务——依次执行</span><br><span class="line">0 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">6 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">7 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">8 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">9 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">10 &lt;NSThread: 0x600002544540&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个并发队列，然后同步执行</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+同步执行</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueSyncExecute</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;并发队列+同步任务——依次执行&quot;</span>)</span><br><span class="line">        <span class="comment">//以下代码输出顺序始终为0...10,且线程始终为主线程</span></span><br><span class="line">        <span class="keyword">let</span> conQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.wjw.swiftTips.concurrentQueue&quot;</span>, qos: .default, attributes: .concurrent  , autoreleaseFrequency: .workItem, target: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">            conQueue.sync &#123;</span><br><span class="line">                sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">                <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果依旧是这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">并发队列+同步任务——依次执行</span><br><span class="line">0 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">4 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">6 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">7 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">8 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">9 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">10 &lt;NSThread: 0x6000030008c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由以上可以确定，就是是并发队列，同步执行的任务，只会在主线程中依次执行。</p><h3 id="3-4-并行队列中异步执行任务"><a href="#3-4-并行队列中异步执行任务" class="headerlink" title="3.4 并行队列中异步执行任务"></a>3.4 并行队列中异步执行任务</h3><p>全局队列中异步执行多个任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发队列+异步任务</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">concurrentQueueAsyncExecute</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;并发队列+异步任务  开启多个线程并发执行&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">      sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)<span class="comment">//休眠时间随机</span></span><br><span class="line">      <span class="built_in">print</span>(i,<span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现打印结果迅速，并不会像第一种情形，每次打印都等待随机延迟时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">并发队列+异步任务——开启多个线程并发执行</span><br><span class="line">0 &lt;NSThread: 0x600003031280&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2 &lt;NSThread: 0x600003005c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">3 &lt;NSThread: 0x600003008880&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">5 &lt;NSThread: 0x600003006280&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">8 &lt;NSThread: 0x600003007380&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">9 &lt;NSThread: 0x600003048e80&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">1 &lt;NSThread: 0x60000306c440&gt;&#123;number = 13, name = (null)&#125;</span><br><span class="line">4 &lt;NSThread: 0x600003031280&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">7 &lt;NSThread: 0x600003005c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">10 &lt;NSThread: 0x600003008880&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">6 &lt;NSThread: 0x600003074300&gt;&#123;number = 14, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>是并发+异步编程提升了程序的处理效率。</p><p>实际上，同步就是在当前线程中执行任务。异步就是GCD会创建新的线程，在多个cpu核心里执行任务。从而利用硬件性能，提高程序运行效率。</p><p>关于队列的串行，并行网上许多资料也提到，并行叫并发更合适。</p><p>并发字面意思体现在这些多个任务同时被提交给CPU,它们的执行期间并排执行的时间差异很大时，并行的描述并不形象。例如一个1ms执行完的任务和一个10min执行的任务并行执行的时间只有1ms，但是说成是并发，就可以理解为他们一同出发，谁先到达终点，我们就不用管了，也管不了。</p><p>当然这都是些文字游戏，主要能帮我们加深理解。</p><h2 id="4、GCD-group"><a href="#4、GCD-group" class="headerlink" title="4、GCD group"></a>4、GCD group</h2><h3 id="4-1-GCD-group的使用"><a href="#4-1-GCD-group的使用" class="headerlink" title="4.1 GCD group的使用"></a>4.1 GCD group的使用</h3><p>实际开发当中，由于异步执行结束的时间不确定，我们在很多场景下会遇到要求任务A，B执行完以后，任务C才执行。A,B这类任务是前置任务，C是后置任务。为满足这样的场景。利用group就可以很方便的实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">groupTest1</span>()</span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;gcd group的使用&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">  <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务A-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务B-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务C-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//group完成时，指定在某个队列中执行一个后续任务</span></span><br><span class="line">  group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group中所有的任务都完成了,执行此处操作&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，group结束时，可以用notify和wait来通知任务执行完的状态,其中，notify不能设置超时时间，而wait可以。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> group.wait(timeout: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> .success:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;group 执行完成&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .timedOut:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;group 执行超时&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-group-enter-group-leave"><a href="#4-2-group-enter-group-leave" class="headerlink" title="4.2 group.enter(), group.leave()"></a>4.2 group.enter(), group.leave()</h3><p>group.enter() 和 group.leave() 必须成对出现。</p><p>group.enter() 出现在任务执行开始前，group.leave() 出现在任务执行结束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">groupTest2</span>()</span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;gcd group的使用&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务A-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务B-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  group.enter()</span><br><span class="line">  queue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务C-----&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">    group.leave()</span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group中所有的任务都完成了&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来和不加enter,leave并没有太大区别，但是第一个示例，我们的任务都是在自己定义的队列里执行。倘若，我们的拿不到执行任务的队列，比如执行任务的队列是第三方库提供的。我们就需要用到这一对操作。</p><h2 id="5-延迟执行-asyncAfter"><a href="#5-延迟执行-asyncAfter" class="headerlink" title="5. 延迟执行 asyncAfter"></a>5. 延迟执行 asyncAfter</h2><p>延迟执行很简单，利用asyncAfter 即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">dispatchAfter</span>()</span> &#123;</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().asyncAfter(deadline: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span> ) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">5</span>, <span class="string">&quot;秒之后执行&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、信号量"><a href="#6、信号量" class="headerlink" title="6、信号量"></a>6、信号量</h2><p>信号量是多线程编程中标识可用资源数。 由于计算机必须具备了可用资源才能执行程序，我们可以利用信号量这一特点，需求来完成一些骚操作。</p><ol><li><p>信号量的创建  let semaphore = DispatchSemaphore.init(value: 0)</p></li><li><p>信号量的-1 wait   semaphore.wait() </p><p>信号量&gt;0时，可以执行代码区，并把信号量-1，当信号量为0时，后续提交的任务都要等待。</p></li><li><p>信号量的+1   semaphore.singnal()</p><p>代码区执行完信号量+1</p></li></ol><ul><li><p>信号量可以处理异步任务的同步</p><p>我们把信号量设置为0，完成任务时发送一次信号，标识只有一个可用资源，那么其它线程执行到这里就只能放行一个，完成了-1.从而达到把异步任务同步化的目的。这里把异步任务同步化处理一般是为了满足具体的业务需求，并不会和异步编程能提高程序运行效率相矛盾。</p></li><li><p>设置异步线程的最大任务并发数max</p><p>把信号量的值设置为最大并发数，执行任务前先-1， 完成了+1；当提交的任务数大于max，时，只要执行中的任务还没有释放资源，就不会再有新的任务执行。</p></li><li><p>设置锁</p><p>把信号量的值设置为1，执行任务时，先-1，就可以阻塞当前线程，</p></li></ul><h3 id="6-1-信号量处理同步"><a href="#6-1-信号量处理同步" class="headerlink" title="6.1 信号量处理同步"></a>6.1 信号量处理同步</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量处理同步</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreSync</span>()</span> &#123;</span><br><span class="line">  <span class="comment">//创建信号量为0</span></span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">0</span>)</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">    sleep(arc4random()<span class="operator">%</span><span class="number">3</span>)</span><br><span class="line">    <span class="comment">//信号量+1</span></span><br><span class="line">    semaphore.signal()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待，信号量大于0，可以继续执行并将信号量-1，信号量=0,阻塞</span></span><br><span class="line">  <span class="keyword">switch</span> semaphore.wait(timeout: <span class="type">DispatchTime</span>.now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> .success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信号量控制的同步任务完成&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .timedOut:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信号量控制的同步任务超时&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-信号量控制最大并发量"><a href="#6-2-信号量控制最大并发量" class="headerlink" title="6.2 信号量控制最大并发量"></a>6.2 信号量控制最大并发量</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量控制最大并发量</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreMaxConcurrent</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;信号量控制最大并发量&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span> &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">      sleep(arc4random() <span class="operator">%</span> <span class="number">3</span>)</span><br><span class="line">      <span class="built_in">print</span>(i, <span class="type">Thread</span>.current)</span><br><span class="line">      semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-锁"><a href="#6-3-锁" class="headerlink" title="6.3 锁"></a>6.3 锁</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>信号量枷锁</span><br><span class="line"><span class="keyword">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">semaphoreAsLock</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;信号量枷锁&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">1</span>)</span><br><span class="line">  semaphore.wait()</span><br><span class="line">  <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模拟任务&quot;</span>, <span class="type">Thread</span>.current)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;swift5-x-中-GCD&quot;&gt;&lt;a href=&quot;#swift5-x-中-GCD&quot; class=&quot;headerlink&quot; title=&quot;swift5.x 中 GCD&quot;&gt;&lt;/a&gt;swift5.x 中 GCD&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;swift 5.x对GCD封装了更加便捷的API,通过这些丰富的API,可以轻松实现多线程编程.&lt;/p&gt;
&lt;h2 id=&quot;0-队列和任务&quot;&gt;&lt;a href=&quot;#0-队列和任务&quot; class=&quot;headerlink&quot; title=&quot;0. 队列和任务&quot;&gt;&lt;/a&gt;0. 队列和任务&lt;/h2&gt;&lt;p&gt;在iOS多线程编程的术语里，最先要理解的两个概念就是队列和任务。&lt;/p&gt;
&lt;p&gt;队列：就是任务执行的一个排队的空间。分为串行队列，并发队列。&lt;/p&gt;
&lt;p&gt;任务：任务是计算机要处理的一段程序。&lt;/p&gt;
&lt;p&gt;同步处理任务，就像是接力棒赛跑，上个人跑完了自己的路程，下个人继续下一段赛程，它有一个先后顺序。&lt;/p&gt;
&lt;p&gt;异步处理任务，是针对多核计算机的，在单核计算机里是没有多线程的概念的，也就没有异步处理任务的说法，所有提交给CPU的任务，只有排队，一个个的处理。多核计算机异步处理任务，就是多个任务系统会统一调度，让CPU多个核心去同时处理多个任务。&lt;strong&gt;也是多线程编程的原因所在，多线程编程让充分发挥系统性能，提高程序运行效率。&lt;/strong&gt;多线程编程就是程序员利用系统提供的API,根据业务要求编写出高效的程序。&lt;/p&gt;
&lt;p&gt; 苹果提供的GCD便是一个多多线程编程的强大类库。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCD可用于多核的并行运算， &lt;/li&gt;
&lt;li&gt;GCD会自动利用更多的CPU内核&lt;/li&gt;
&lt;li&gt;GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://jarvissky.com/categories/iOS/"/>
    
    <category term="swift" scheme="http://jarvissky.com/categories/iOS/swift/"/>
    
    
    <category term="swift" scheme="http://jarvissky.com/tags/swift/"/>
    
    <category term="GCD" scheme="http://jarvissky.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>swift 可选值</title>
    <link href="http://jarvissky.com/2021/04/04/swift-%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    <id>http://jarvissky.com/2021/04/04/swift-%E5%8F%AF%E9%80%89%E5%80%BC/</id>
    <published>2021-04-04T09:10:51.000Z</published>
    <updated>2021-04-05T06:22:18.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift-可选值"><a href="#swift-可选值" class="headerlink" title="swift 可选值"></a>swift 可选值</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>swift 是苹果的二儿子，和大儿子OC比起来有很多优势，他更加接近现代编程语言的范式，类似解释语言的语法习惯，却是名副其实的强类型语言。接触最初就会遇到一个swift和OC明显不同的数据类型，<strong>可选值 | Optional Value</strong>。</p><p>中文翻译直接理解的话就是可以选来用也可以不选。个人认为把他理解为未定型更合符合普通的思维习惯,有点像JavaScript中的未定型。</p> <span id="more"></span><p>我们可以这样声明一个可选值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name : String?</span><br></pre></td></tr></table></figure><p>用标识符var 声明一个变量 name ，后面的？表示它是一个可选值。在后续使用中它的值可能是字符串 “张三”。也可能是一个空值 nil 。</p><p>这里有一点和OC不同的是，OC中的基本数据类型都会有默认的初始值，例如 NSInter 默认为0，CGFloat 默认为 0.0。但是swift里由于可选值概念的存在，基础数据类型（int, double, bool）没有值时也可以是nil.<br>一个可选值没有初始值的话是不可以使用的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;swift-可选值&quot;&gt;&lt;a href=&quot;#swift-可选值&quot; class=&quot;headerlink&quot; title=&quot;swift 可选值&quot;&gt;&lt;/a&gt;swift 可选值&lt;/h1&gt;&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h2&gt;&lt;p&gt;swift 是苹果的二儿子，和大儿子OC比起来有很多优势，他更加接近现代编程语言的范式，类似解释语言的语法习惯，却是名副其实的强类型语言。接触最初就会遇到一个swift和OC明显不同的数据类型，&lt;strong&gt;可选值 | Optional Value&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;中文翻译直接理解的话就是可以选来用也可以不选。个人认为把他理解为未定型更合符合普通的思维习惯,有点像JavaScript中的未定型。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://jarvissky.com/categories/iOS/"/>
    
    <category term="swift" scheme="http://jarvissky.com/categories/iOS/swift/"/>
    
    
    <category term="swift" scheme="http://jarvissky.com/tags/swift/"/>
    
    <category term="可选值" scheme="http://jarvissky.com/tags/%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jarvissky.com/2021/04/04/hello-world/"/>
    <id>http://jarvissky.com/2021/04/04/hello-world/</id>
    <published>2021-04-04T03:51:04.346Z</published>
    <updated>2021-04-05T06:10:16.637Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://jarvissky.com/tags/hexo/"/>
    
  </entry>
  
</feed>
